# 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

## 핵심 정리

### 핵심 정리 1. private 생성자 + public static final 필드

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();

    private Elvis() {
    }

    @Override
    public void sing() {
        System.out.println("singing~");
    }
}
```

- `장점, 간결하고 싱글턴임을 API에 들어낼 수 있다.`
- `단점 1, 싱글톤을 사용하는 클라이언트 테스트하기 어려워진다.`

```java
public class Concert {

    private boolean stageOn;

    private IElvis elvis;

    public Concert(IElvis elvis) {
        this.elvis = elvis;
    }

    public void perform() {
        stageOn = true;
        elvis.sing();
    }

    public boolean isStageOn() {
        return stageOn;
    }
}
```

Concert 객체가 Elvis의 클라이언트라고 할 때, Elvis의 구현 클래스를 참조하는 경우 테스트가 어려울 수 있다. 

```java
public interface IElvis {
    void sing();
}

// 인터페이스는 테스트 용이하게한다.
public class Elvis implements IElvis {
    public static final Elvis INSTANCE = new Elvis();
		...
}
```

다만 클라이언트(Concert)가 인터페이스에 의존하는 경우 다음과 같이 의존 객체를 유연하게 대체할 수 있다.

```java
class ConcertTest {

    @Test
    void perform() {
        Concert concert = new Concert(new IElvis() {
            @Override
            public void sing() {
                System.out.println("mock singing~");
            }
        });
        concert.perform();
    }
}
```

- `단점 2, 리플렉션으로 private 생성자를 호출할 수 있다.`

```java
public class ElvisReflection {

    public static void main(String[] args) {
        try {
            Constructor<Elvis> declaredConstructor = Elvis.class.getDeclaredConstructor();
            declaredConstructor.setAccessible(true);
            Elvis elvis = declaredConstructor.INSTANCE;
            Elvis elvis2 = declaredConstructor.INSTANCE;
            elvis.sing();
            elvis2.sing();
            System.out.println(elvis == elvis2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

accessible을 true로 설정하게되면 싱글턴임에도 리플렉션으로 객체 인스턴스 생성할 수 있다. 이에대한 대안으로 아래와 같이 기본 생성자에 조건을 걸어주면 방어할 수 있다.

```java
public class Elvis implements IElvis {
    public static final Elvis INSTANCE = new Elvis();

    private static boolean created;
    
    private Elvis() {
				// 리플렉션 방어
        if (created) {
            throw new UnsupportedOperationException("can't be created by constructor");
        }
        created = true;
    }
		...
}
```

- `단점 3, 역직렬화 할 때 새로운 인스턴스가 생길 수 있다.`

```java
public class Elvis implements IElvis, Serializable {
    public static final ElvisSerialization INSTANCE = new ElvisSerialization();

    private static boolean created;

    private ElvisSerialization() {
    }

		...

		// 해당 메소드를 정의하면 역직렬화로 싱글톤이 깨지는 것을 방어할 수 있다.
    private Object readResolve() {
        return INSTANCE;
    }
}
```

```java
public class ElvisSerializationTest {
    public static void main(String[] args) {
        String file = "elvis.obj";
        // write
        try (ObjectOutput out = new ObjectOutputStream(new FileOutputStream(file))) {
            out.writeObject(Elvis.INSTANCE);
        } catch (Exception e) {
            e.printStackTrace();
        }

        // read
        try (ObjectInput in = new ObjectInputStream(new FileInputStream(file))) {
            Elvis elvis = (Elvis) in.readObject();
            System.out.println(elvis == Elvis.INSTANCE);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 핵심 정리 2. private 생성자 + 정적 팩터리 메서드

- `장점 1. API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.`

```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();

    private Elvis() {
    }

		public static Elvis getInstance() {
        return INSTANCE;
				// 메소드를 통해 인스턴스를 제공하는 경우 
				// 클라이언트 코드에 영향을 주지 않고
				// 새로운 인스턴스를 반환하게 할 수 있다.
				// return new Elvis();
    }

    ...
}
```

- `장점 2. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.`

```java
public class MetaElvis<T> implements IElvis {
    private static final MetaElvis<Object> INSTANCE = new MetaElvis<>();

    // 메소드에 정의된 static <T>의 경우 클래스에 선언된 MetaElvis<T> 제네릭과의 스코프가 다르다.
    // 따라서 해당 메소드에 정의된 MetaElvis<T>는 메소드의 제네릭을 사용하는 것이다.
    @SuppressWarnings("unchecked")
    public static <T> MetaElvis<T> getInstance() {
        return (MetaElvis<T>) INSTANCE;
    }

    public void say(T t) {
        System.out.println("say " + t);
    }

    @Override
    public void sing() {
        System.out.println("singing~");
    }

    public static void main(String[] args) {
        MetaElvis<String> elvis1 = MetaElvis.getInstance();
        MetaElvis<Integer> elvis2 = MetaElvis.getInstance();

        System.out.println(elvis1.equals(elvis2));// true
        // 동일 인스턴스는 맞지만 제네릭 타입이 달라서 불가능
        // System.out.println(elvis1 == elvis2);
        elvis1.say("hello");
        elvis2.say(1235);
    }
}
```

```java
@SuppressWarnings("unchecked")
public static <T> MetaElvis<T> getInstance() {
    return (MetaElvis<T>) INSTANCE;
}
```

- 메소드에 정의된 static <T>의 경우 클래스에 선언된 MetaElvis<T> 제네릭과의 스코프가 다르다.
- 따라서 해당 메소드에 정의된 MetaElvis<T>는 메소드의 제네릭을 사용하는 것이다.

```java
public class MetaElvis<T> implements IElvis {
		...
		
		public void say(T t) {
		    System.out.println("say " + t);
		}
}
```

- 해당 메소드에 사용된 제네릭 타입은 클래스에 정의된 class MetaElvis<T> 제네릭 타입을 사용한다.
- `장점 3. 정적 팩터리의 메서드 참조를 공급자(Supplier)로 사용할 수 있다.`

```java
public class Concert {

    public void start(Supplier<Singer> supplier) {
        Singer singer = supplier.get();
        singer.sing();
    }

    public static void main(String[] args) {
        Concert concert = new Concert();
        concert.start(Elvis::getInstance);
    }
}
```

### 핵심 정리 3. 열거 타입

- `가장 간결한 방법이며 직렬화와 리플렉션에도 안전하다.`
- `대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.`

```java
public enum Elvis implements IElvis {
    INSTANCE;

    public void sing() {
        System.out.println("enum elvis singing!");
    }

    public static void main(String[] args) {
        Elvis elvis = Elvis.INSTANCE;
        elvis.sing();
    }
}
```

- enum 방식으로 싱글턴을 구현하는 경우 리플렉션과 역직렬화 문제를 방어해준다.

## 완벽 공략

- `p23, 리플렉션 API로 private 생성자 호출하기`
- `p24, 메서드 참조를 공급자(Supplier)로 사용할 수 있다.`
- `p24, Supplier<T>, 함수형 인터페이스`
- `p24, 직렬화, 역직렬화, Serializable, transient`

### 완벽 공략 11. 메소드 참조

```java
public class Person {
    LocalDate birthday;

    public Person(LocalDate birthday) {
        this.birthday = birthday;
    }

    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }

    public int getAge() {
        return LocalDate.now().getYear() - birthday.getYear();
    }

    public static void main(String[] args) {
        List<Person> personList = new ArrayList<>();
        personList.add(new Person(LocalDate.of(2011, 3, 11)));
        personList.add(new Person(LocalDate.of(2031, 8, 7)));
        personList.add(new Person(LocalDate.of(2001, 4, 21)));

        personList.sort(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.birthday.compareTo(o2.birthday);
            }
        });

        System.out.println(personList);
    }
}
```

- `메소드 하나만 호출하는 람다 표현식을 줄여쓰는 방법`

```java
personList.sort((o1, o2) -> o1.birthday.compareTo(o2.birthday));
```

- `스태틱 메소드 레퍼런스`

```java
personList.sort(Person::compareByAge);
```

- `인스턴스 메소드 레퍼런스`

```java
public class Person {
		...
		public int compareByAgeMethodRef(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }
}
---

Person person = new Person(null);
personList.sort(person::compareByAgeMethodRef);
```

- `임의 객체의 인스턴스 메소드 레퍼런스`

```java
public class Person {
		...
		public int compareByAgeMethodRef(Person b) {
		    return this.birthday.compareTo(b.birthday);
		}
}
---

personList.sort(Person::compareByAgeMethodRef);
```

임의 객체 인스턴스 메소드의 경우 첫번째 인자가 자기 자신이다.

- `생성자 레퍼런스`

```java
List<LocalDate> dates = new ArrayList<>();
dates.add(LocalDate.of(1933, 2, 19));
dates.add(LocalDate.of(2033, 3, 29));
dates.add(LocalDate.of(2003, 4, 15));
List<Person> newPersonList = dates.stream()
        .map(Person::new)
        .collect(Collectors.toList());
```

- [https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)

### 완벽 공략 12. 함수형 인터페이스

- `자바가 제공하는 기본 함수형 인터페이스`

```java
import java.util.function.*;

public class DefaultFunctions {
    public static void main(String[] args) {
        // 인자와 반환 타입을 지정하여 반환
        Function<Integer, String> intToString = (i) -> "hello";

        // 인자는 안받고 지정 타입으로 반환
        Supplier<Integer> integerSupplier;
        Supplier<Person> personSupplier = Person::new;
        Function<LocalDate, Person> localDateToPerson = Person::new;

        // 인자를 지정하고 void 타입으로 반환
        Consumer<Integer> integerConsumer = System.out::println;
        
        // 인자를 지정하고 boolean 타입으로 반환
        Predicate<Integer> predicate;
    }
}
```

- `함수형 인터페이스는 람다 표현식과 메소드 참조에 대한 “타겟 타입”을 제공한다.`
- `타겟 타입은 변수 할당, 메소드 호출, 타입 변환에 활용할 수 있다.`

```java
public class UsageOfFunctions {
    public static void main(String[] args) {
        List<LocalDate> dates = new ArrayList<>();
        dates.add(LocalDate.of(1933, 2, 19));
        dates.add(LocalDate.of(2033, 3, 29));
        dates.add(LocalDate.of(2003, 4, 15));

        Predicate<LocalDate> localDatePredicate = d -> d.isBefore(LocalDate.of(2000, 1, 1));
        Function<LocalDate, Integer> getYear = LocalDate::getYear;
        List<Integer> years = dates.stream()
                .filter(localDatePredicate)
                .map(getYear)
                .collect(Collectors.toList());
    }
}
```

- `자바에서 제공하는 기본 함수형 인터페이스 익혀 둘 것. (java.util.function 패키지)`
- `함수형 인터페이스를 만드는 방법.`

```java
@FunctionalInterface
public interface MyFunction {
    String valueOf(Integer integer);
}
```

- `심화 학습 1) Understanding Java method invocation with invokedynamic`
    - [https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic](https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic)
- `심화 학습 2) LambdaMetaFactory`
    - [https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html](https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html)

### 완벽 공략 13. 객체 직렬화

- `객체를 바이트스트림으로 상호 변환하는 기술`
- `바이트스트림으로 변환한 객체를 파일로 저장하거나 네트워트를 통해 다른 시스템으로 전송할 수 있다.`
- `Serializable 인터페이스 구현`
    - Serializable 인터페이스를 구현해야 직렬화 가능
- `transient를 사용해서 직렬화 하지 않을 필드 선언하기`

```java
public class Book implements Serializable {
		...
    private transient int numberOfSold;
}
```

- `serialVersionUID는 언제 왜 사용하는가?`
- `심화 학습) 객체 직렬화 스팩`
    - [https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html](https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html)

```java
// 직렬화 대상 클래스
public class Book implements Serializable {
    private String isbn;
    private String title;
    private String author;
    private LocalDate published;
    private int numberOfSold;

    public Book(String isbn, String title, String author, LocalDate published) {
        this.isbn = isbn;
        this.title = title;
        this.author = author;
        this.published = published;
    }

    public String getIsbn() {
        return isbn;
    }

    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }
		...

    @Override
    public String toString() {
        return "Book{" +
                "isbn='" + isbn + '\'' +
                ", title='" + title + '\'' +
                ", author='" + author + '\'' +
                ", published=" + published +
                ", numberOfSold=" + numberOfSold +
                '}';
    }
}
```

```java
public class SerializationExample {

    private void serialize(Book book) {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("book.obj"))) {
            out.writeObject(book);
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Book deserialize() {
        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("book.obj"))) {
            return (Book) in.readObject();
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        Book book = new Book("123", "이펙티브자바3판", "홍길동", LocalDate.of(2006, 9, 22));
        book.setNumberOfSold(200);

        SerializationExample example = new SerializationExample();
        example.serialize(book);
        Book deserializeBook = example.deserialize();

        System.out.println(book);
        System.out.println(deserializeBook);
    }
}
```

- 직렬화는 왜 필요한가?
    - 메모리에 올라온 객체를 다른 시스템에서 해당 객체를 사용하고 싶은 경우 사용
- static 필드는 직렬화 되지 않는다.

```java
public class Book implements Serializable {
    public static String name;
}
```

- 클래스의 스펙이 달라진 경우(필드가 추가되거나 삭제된 경우) 역직렬화가 될까?
    - 클래스가 달라진 경우 serialVersionUID가 다르게 생성되기 때문에 역직렬화가 되지 않는다.
    - 주요한점은 serialVersionUID가 다르기 때문에 역직렬화가 안되는 것이다 직렬화, 역직렬화할 때 해당 값을 동일하게 맞춰서 수행한다면 역직렬화가 된다.
