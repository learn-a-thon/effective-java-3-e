# 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 핵심 정리

- `상속용 클래스는 내부 구현을 문서로 남겨야 한다.`
    - `@implSpec을 사용할 수 있다.`

> 좋은 API란 어떻게가 아니라 무엇을 하는지를 설명 해야한다.
> 
- 해당 아이템의 내용은 위 격언과 반대되는 내용이다.
- 서울역을 어떻게 가는지 구체적으로 이야기하는 것이 아니라 서울역을 간다 라고만 설명하라는 의미

```java
/**
 * Example class for java documentation for extendable class
 */
public class ExtendableClass {

    /**
     * This method can be overridden to print any message.
     *
     * @implSpec
     * Please use System.out.println().
     */
    protected void doSomething() {
        System.out.println("hello");
    }
}
```

```java
$ javadoc -d {저장경로} {문서화 타겟 경로} -tag "implSpec:a:Implementation Requirements:"

ex) javadoc -d target/apidoc src/main/java/item19/impespec/* -tag "implSpec:a:Implementation Requirements:"
```

- 자바 문서 명령어 참고: javadoc -h
- `내부 동작 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드로 공개해야 한다.`
- `상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.`
- `상속용 클래스의 생성자는 재정의 가능한 메서드를 호출해서는 안 된다.`
    - `Cloneable(아이템 13)과 Serializable(아이템 86)을 구현할 때 조심해야 한다.`

```java
// 재정의 가능 메서드를 호출하는 생성자 - 따라 하지 말 것! (115쪽)
public class Super {
    // 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}
```

```java
// 생성자에서 호출하는 메서드를 재정의했을 때의 문제를 보여준다. (126쪽)
public final class Sub extends Super {
    // 초기화되지 않은 final 필드. 생성자에서 초기화한다.
    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    // 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.
    @Override 
		public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

- Sub 생성자를 호출하는 시점에 상위 클래스의 생성자를 먼저 호출한다.
- 이때 Sub에 정의된 instant 필드는 null 인 상태로 한번 호출하게 되는 문제가 있다.(final 임에도…)
- `상속용으로 설계한 클래스가 아니라면 상속을 금지한다.`
    - `final 클래스 또는 private 생성자`
        - 추가로 package-private 생성자로 만드는 방법을 고려할 수 있다.
            - 패키지 내부에서만 상속이 가능해서 좀 더 유연한 장점이 있다.