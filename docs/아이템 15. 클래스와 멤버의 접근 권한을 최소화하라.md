# 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

## 핵심 정리1: 구현과 API를 분리하는 “정보 은닉”의 장점

- 시스템 개발 속도를 높인다.
    - 여러 컴포넌트를 병렬로 개발할 수 있기 때문에
- 시스템 관리 비용을 낮춘다.
    - 컴포넌트를 더 빨리 파악할 수 있기 때문에
- 성능 최적화에 도움을 준다.
    - 프로파일링을 통해 최적화할 컴포넌트를 찾고 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 개선할 수 있기 때문에
- 소프트웨어 재사용성을 높인다.
    - 독자적인 컴포넌트인 경우
- 시스템 개발 난이도를 낮춘다.
    - 전체를 만들기 전에 개별 컴포넌트를 검증할 수 있기 때문에

## 핵심 정리2: 클래스와 인터페이스의 접근 제한자 사용 원칙

- `모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.`
- `톱레벨 클래스와 인터페이스에 package-private 또는 public을 쓸 수 있다.`
    - `public으로 선언하면 API가 되므로 하위 호환성을 유지하려면 영원히 관리해야한다.`
    - `패키지 외부에서 쓰지 않을 클래스나 인터페이스라면 package-private으로 선언한다.`

MemberService 인터페이스는 외부에 노출하기 위한 명세로써 public 접근 제어자로 설정

```java
public interface MemberService {
}
```

인터페이스를 구현한 클래스는 package-private level이 적절(package-private으로 선언하면 해당 패키지 안에서만 이용할 수 있다.)

```java
class DefaultMemberService implements MemberService {
}
```

도메인 클래스는 public으로 지정

```java
public class Member {
}
```

- `한 클래스에서만 사용하는 package-private 클래스나 인터페이스는 해당 클래스에 private static으로 중첩 시키자.(아이템 24)`

**Q.** **왜 private static 일까? private static class와 private class의 차이점은?** 

- private inner 클래스는 외부 참조 값(감싸고 있는 클래스의 인스턴스)을 가지고 있지만 private static inner 클래스는 가지고 있지 않고 독립적인 존재
- 외부(감싸고 있는 쪽) 클래스에서 내부 클래스를 사용하는 단방향인 경우 private static을 사용하는 것이 적절하다.
    - DefaultMemberService → PrivateStaticMember를 참조하고자 하는 경우

```java
class DefaultMemberService implements MemberService {
    
    private String name;
    
    private static class PrivateStaticMember {
    }
    
    private class PrivateMember {
				void doPrint() {
						System.out.println(name);
				}
    }

    public static void main(String[] args) {
        // DefaultMemberService의 참조값을 가지고 있다.
        Arrays.stream(PrivateMember.class.getDeclaredFields()).forEach(System.out::println);
    }
}
```

## 핵심 정리 3: 멤버(필드, 메서드, 중첩 클래스/인터페이스)의 접근 제한자 원칙

- `private과 package-private은 내부 구현`
- `public 클래스의 protected와 public은 공개 API`

```java
public class ItemService {
    // private field
    private MemberService memberService;

    // package-private field
    boolean onSale;

    // protected field
    protected int saleRate;

    // public method
    public ItemService(MemberService memberService) {
        this.memberService = memberService;
    }
}
```

- `코드를 테스트 하는 목적으로 private을 package-private으로 풀어주는 것은 허용할 수 있다. 하지만 테스트만을 위해서 멤버를 공개 API로 만들어서는 안된다.(테스트를 같은 패키지에 만든다면 그럴 필요도 없다.)`

```java
@ExtendWith(MockitoExtension.class)
class ItemServiceTest {

    @Mock
    MemberService memberService;

    @Test
    void itemService() {
        /* MemberService만을 외부에 공개하기로 했고 DefaultMemberService.class는 내부 공개로서
         * package-private으로 선언했기 때문에 사용하지 못한다.
         * 이를 사용하기 위해서는 MemberService를 필드로 선언하고 @Mock 객체를 생성하여 사용할 수 있다.
         */
        //ItemService itemService = new ItemService(new DefaultMemberService());

        ItemService itemService = new ItemService(memberService);

				assertNotNull(itemService);
        // memberService가 private field로 선언되어 있어 접근 불가능
        //assertNotNull(itemService.memberService);
        assertNotNull(itemService.getMemberService());
    }
}
```

테스트를 위해서 memberService 필드를 public으로 선언하는 것은 지양한다. 만약 테스트를 위해서 memberService 필드가 필요로 한다면 

- memberService @Mock객체로 만들어 사용하기
- memberService 필드를 package-private으로 선언하기
- 만약 getter 메소드를 제공한다면 package-private level로 동일 패키지에서 사용할 수 있도록 허용

```java
public class ItemService {
		// private field
    private MemberService memberService;
    ...

    // public method
    public ItemService(MemberService memberService) {
        if (memberService == null) {
            throw new IllegalArgumentException("MemberService should not be null.");
        }
        this.memberService = memberService;
    }

    // 테스트를 위해서 필드를 외부에 노출(public)하는 것은 지양한다.
    // ex) public 필드, public 메소드
    // package-private으로 제한하기
    MemberService getMemberService() {
        return memberService;
    }
}
```

- `public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.`

최대한 필드는 private 필드로 선언한다.

- `클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.`

```java
public class ItemService {
		public static final String[] NAMES = new String[10];
}
```

위와 같이 필드를 정의한 경우 해당 필드가 오염될 가능성이 높다. 즉, 외부에서 해당 필드를 조회하고 배열 값을 변경할 수 있다는 의미

## 완벽 공략

- `p98, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다.(완벽 공략 13 참고)`
    - 참고

접근 제어자가 private, package-private이여도 공개 API가 될 수 있다.

- `이 제약(아이템 15)은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환 원칙)을 지키기 위해 필요하다.(완벽 공략 26 참고)`

상위 클래스에서는 public hello()를 선언 하위 클래스에서는 overriding하여 hello를 private으로 선언한 경우, 리스코프 치환 원칙에 따라 상위 타입의 인스턴스에서 하위 타입의 인스턴스로 변경하면 해당 규칙이 깨지게 된다. 

이때 클래스는 인터페이스가 정의한 모든 메서드를 public으로 선언해야 한다.

- `public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.`

멀티 스레드는 순서를 보장하지 않기 때문에 스레드 안전하지 않다고 할 수 있다.

**race condition**: 누가 먼저 실행 하느냐에 따라 결과가 달라지는, 예측할 수 없는

- `기본 타입 값(primitive type) 혹은 불변 객체를 참조하라`

가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익(스레드 안전X)이 그대로 적용된다. 즉, 객체가 오염될 수 있다는 의미이다.

## 완벽 공략 31. 자바 플랫폼 모듈 시스템(Java Platform Module System, JPMS)

자바 9에서는 모듈 시스템이라는 개념이 도입되면서 두 가지 암묵적 접근 수준이 추가되었다.

- `JSR-376 스팩으로 정의한 자바의 모듈 시스템`
- `안정성 - 순환 참조 허용하지 않음, 실행시 필요한 모듈 확인, 한 패키지는 한 모듈에서만 공개할 수 있음.`
- `캡슐화 - public 인터페이스나 클래스라 하더라도, 공개된 패키지만 사용할 수 있다. 내부 구현을 보호하는 수단으로 사용할 수 있다.(하지만 모듈이 아닌 곳에서 참조한다면..)`
- `확장성 - 필요한 자바 플랫폼 모듈만 모아서 최적의 JRE를 구성할 수 있다. 작은 기기에서 구동할 애플리케이션을 개발할 때 유용하다.`

---

- 프로젝트 직쏘 참고
- 컴포넌트간의 관계를 표현하는 방법
    - 기존에는 classpath(jar간의 관계)로 표현
    - classpath 방식의 문제점이 애플리케이션이 동작할 때 까지 해당하는 jar 파일이 클래스 패스에 없더라도 사용하는 시점까지 알 수 없다.(없으면 에러, 런타임 시점에…)