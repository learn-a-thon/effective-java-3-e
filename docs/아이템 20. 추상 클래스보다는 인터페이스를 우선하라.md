# 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

## 핵심 정리

`인터페이스의 장점`

- `자바 8부터 인터페이스도 디폴트 메서드를 제공할 수 있다. (완벽 공략 3)`
- `기존 클래스도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.`

```java
public interface TimeClient {

    void setTime(int hour, int minute, int second);
    void setDate(int day, int month, int year);
    void setDateAndTime(int day, int month, int year,
                        int hour, int minute, int second);
    LocalDateTime getLocalDateTime();

    static ZoneId getZonedId(String zoneString) {
        try {
            return ZoneId.of(zoneString);
        } catch (DateTimeException e) {
            System.err.println("Invalid time zone: " + zoneString + "; using default time zone instead.");
            return ZoneId.systemDefault();
        }
    }

    default ZonedDateTime getZonedDateTime(String zoneString) {
        return ZonedDateTime.of(getLocalDateTime(), getZonedId(zoneString));
    }
}
```

- 다른 패키지에 공개적으로 선언된 인터페이스의 경우 어떤 클래스가 해당 인터페이스를 구현했는지 알 수 없기 때문에 인터페이스의 기능을 추가하는 것에 어려움이 있다. 이를 위한 대안으로 인터페이스에 default 메소드를 추가하는 것으로 하위 호환성을 유지하며 기능을 확장할 수 있다.
    - default 메소드는 java8 부터 사용할 수 있다.
- 추가로 인터페이스에는 static 메소드 선언이 가능하다.
- `인터페이스는 믹스인(mixtin) 정의에 안성맞춤이다. (선택적인 기능 추가)`
    - 부가적인 기능을 추가할 수 있다.(인터페이스는 다중 상속이 가능하다는 의미)
- `계층구조가 없는 타입 프레임워크를 만들 수 있다.`

```java
public interface SingerSongwriter extends Singer, Songwriter {
    AudioClip strum();
    void actSensitive();
}
```

- 인터페이스가 다중 상속이 가능하기 때문에 확장하기 용이하다는 의미
- `래퍼 클래스와 함께 사용하면 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다. (아이템 18)`
- `구현이 명백한 것은 인터페이스의 디폴트 메서드를 사용해 프로그래머의 일감을 덜어 줄 수 있다.`

`인터페이스와 추상 골격(skeletal) 클래스`

추상 골격 == 추상 클래스

- `인터페이스와 추상 클래스의 장점을 모두 취할 수 있다.`
    - `인터페이스 - 디폴트 메서드 구현`
    - `추상 골격 클래스 - 나머지 메서드 구현`
    - `템플릿 메서드 패턴`

```java
// 코드 20-1 골격 구현을 사용해 완성한 구체 클래스 (133쪽)
public class IntArrays {
    static List<Integer> intArrayAsList(int[] a) {
        Objects.requireNonNull(a);

        // 다이아몬드 연산자를 이렇게 사용하는 건 자바 9부터 가능하다.
        // 더 낮은 버전을 사용한다면 <Integer>로 수정하자.
        return new AbstractList<>() {
            @Override
            public Integer get(int i) {
                return a[i];  // 오토박싱(아이템 6)
            }

            @Override
            public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val;     // 오토언박싱
                return oldVal;  // 오토박싱
            }

            @Override
            public int size() {
                return a.length;
            }
        };
    }

    public static void main(String[] args) {
        int[] a = new int[10];
        for (int i = 0; i < a.length; i++)
            a[i] = i;

        List<Integer> list = intArrayAsList(a);
        Collections.shuffle(list);
        System.out.println(list);
    }
}
```

- 구현할 인터페이스에 정의된 모든 메소드를 구현하는 것이 아니라 추상 클래스(골격 클래스)를 활용하여 필요한 메소드만 구현할 수 있도록 하는 것을 의미
- `다중 상속을 시뮬레이트할 수 있다.`

```java
public class MyCat extends AbstractCat implements Flyable {

    private MyFlyable myFlyable = new MyFlyable();

    @Override
    protected String sound() {
        return "인싸 고양이 두 마리가 나가신다!";
    }

    @Override
    protected String name() {
        return "유미";
    }

    public static void main(String[] args) {
        MyCat myCat = new MyCat();
        System.out.println(myCat.sound());
        System.out.println(myCat.name());
        myCat.fly();
    }

    @Override
    public void fly() {
        this.myFlyable.fly();
    }

    private class MyFlyable extends AbstractFlyable {
        @Override
        public void fly() {
            System.out.println("날아라.");
        }
    }
}
```

- 추상 클래스는 다중 상속이 불가능 하기 때문에 내부 클래스(private inner class)를 활용해서 기능을 확장할 수 있다.
    - 내부 클래스에서 구현하고자 하는 클래스를 상속받아서 구현하고 해당 인스턴스를 활용해서 기능을 확장할 수 있다.
- `골격 구현은 상속용 클래스이기 때문에 아이템 19를 따라야 한다`
    - 상속 구조와 관련된 문서화를 해야한다.

## 완벽 공략

- `p132, 템플릿 메서드 패턴`
- `p135, 디폴트 메서드는 equals, hashCode, toString 같은 Object 메서드를 재정의할 수 없기 때문이다.`

### 완벽 공략 36. 템플릿 메서드 패턴

`알고리즘 구조를 서브 클래스가 확장할 수 있도록 템플릿으로 제공하는 방법.`

- `추상 클래스는 템플릿을 제공하고 하위 클래스는 구체적인 알고리즘을 제공한다.`

상속을 활용한 디자인 패턴

**템플릿 메서드 패턴이 적용된 클래스**

```java
public abstract class FileProcessor {

    private String path;

    public FileProcessor(String path) {
        this.path = path;
    }

    public final int process() {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;
            while ((line = reader.readLine()) != null) {
                result = getResult(result, Integer.parseInt(line));
            }
            return result;
        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }

    protected abstract int getResult(int result, int number);
}
```

**템플릿 클래스를 구현하는 하위 클래스**

```java
public class Plus extends FileProcessor {
    public Plus(String path) {
        super(path);
    }

    @Override
    protected int getResult(int result, int number) {
        return result + number;
    }
}
```

- **템플릿 콜백 패턴**을 활용하면 상속 없이 기능을 확장할 수 있다.

```java
// 템플릿 콜백 패턴 적용
public class AdvanceFileProcessor {

    private String path;

    public AdvanceFileProcessor(String path) {
        this.path = path;
    }

    public final int process(BiFunction<Integer, Integer, Integer> operator) {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            int result = 0;
            String line = null;
            while ((line = reader.readLine()) != null) {
                result = operator.apply(result, Integer.parseInt(line));
            }
            return result;
        } catch (IOException e) {
            throw new IllegalArgumentException(path + "에 해당하는 파일이 없습니다.", e);
        }
    }
}

// 하위 클래스
public class AdvancePlus extends AdvanceFileProcessor {
    public AdvancePlus(String path) {
        super(path);
    }
}

// 클라이언트
public class Client {

    public static void main(String[] args) {
				...
        // 상속 없이 기능 확장하기
        AdvanceFileProcessor advanceFileProcessor = new AdvancePlus(path);
        System.out.println(advanceFileProcessor.process(Integer::sum));
    }
}
```

### 완벽 공략 37. 디폴트 메서드와 Object 메서드

`인터페이스의 디폴트 메서드로 Object 메서드를 재정의 할 수 없는 이유`

```java
public interface MyInterface {

//    default String toString() {
//        return "myString";
//    }
//
//    default int hashCode() {
//        return 10;
//    }
//
//    default boolean equals(Object o) {
//        return true;
//    }
}
```

- `디폴트 메서드 핵심 목적은 “인터페이스의 진화”.`
- `두 가지 규칙만 유지한다.`
    - `“클래스가 인터페이스를 이긴다.”`
    - `“더 구체적인 인터페이스가 이긴다.”`
- `토이 예제에나 어울리는 기능이다. 실용적이지 않다.`
- `불안정하다.`
- `관련 문서`
    - [https://mail.openjdk.org/pipermail/lambda-dev/2013-March/008435.html](https://mail.openjdk.org/pipermail/lambda-dev/2013-March/008435.html)

```java
public class MyClass extends Object implements MyInterface {
}
```

- 위와 같이 선언한 경우 어떤 부모의 기능을 사용할지 우선순위 결정과 같이 복잡도를 높인다.