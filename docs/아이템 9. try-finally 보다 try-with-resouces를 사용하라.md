# 아이템 9. try-finally 보다 try-with-resouces를 사용하라

## 핵심 정리

- `try-finally는 더이상 최선의 방법이 아니다. (자바7부터)`

**try-finally 구분 자원 해제 예시**

```jsx
public class TopLine {
    // 코드 9-1 try-finally - 더 이상 자원을 회수하는 최선의 방책이 아니다! (47쪽)
    static String firstLineOfFile(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));
        try {
            return br.readLine();
        } finally {
            br.close();
        }
    }

    public static void main(String[] args) throws IOException {
        String path = args[0];
        System.out.println(firstLineOfFile(path));
    }
}
```

- 리소스 반납이 필요한 경우 위와 같은 형태로 finally 구문에 close()를 호출하여 반납하게 된다.

**try-finally 구문 복수 자원 처리 예시**

```jsx
public class Copy {
    private static final int BUFFER_SIZE = 8 * 1024;

    // 코드 9-2 자원이 둘 이상이면 try-finally 방식은 너무 지저분하다! (47쪽)
    static void copy(String src, String dst) throws IOException {
        InputStream in = new FileInputStream(src);
        try {
            OutputStream out = new FileOutputStream(dst);
            try {
                byte[] buf = new byte[BUFFER_SIZE];
                int n;
                while ((n = in.read(buf)) >= 0)
                    out.write(buf, 0, n);
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }

    public static void main(String[] args) throws IOException {
        String src = args[0];
        String dst = args[1];
        copy(src, dst);
    }
}
```

- 복수 자원 처리에 try-finally 구문을 사용할 땐 위와 같은 형태로 처리한다.
- 만약 out.close()를 처리하는 중 exception이 발생하더라도 중첩된 try 구문(InputStream 처리)으로 처리가 가능하다.
- 자원이 늘어남에 따라 코드가 복잡해지고 길어지는 문제가 있다. 가장 좋은 방법은 `try-with-resources`를 사용하는 것이다.
- `try-with-resources를 사용하면 코드가 더 짧고 분명하다.`
- `만들어지는 예외 정보도 훨씬 유용하다.`

**try-with-resources 처리 예시**

```jsx
public class TopLine {
    // 코드 9-3 try-with-resources - 자원을 회수하는 최선책! (48쪽)
    static String firstLineOfFile(String path) throws IOException {
        try (BufferedReader br = new BufferedReader(
                new FileReader(path))) {
            return br.readLine();
        }
    }

    public static void main(String[] args) throws IOException {
        String path = args[0];
        System.out.println(firstLineOfFile(path));
    }
}
```

- try-with-resource 구문에 리소스 반환이 필요한 자원을 명시하면 해당 구문 이후 자동으로 반환된다.
- 자동으로 반환이 가능한 이유는 아래와 같이 리소스의 상위에서 `Cloasable`를 구현하고 있기 때문이다.
    - `Closeable`은 `AutoCloseable`를 상속받고 있다.

```jsx
public abstract class Reader implements Readable, Closeable {

    private static final int TRANSFER_BUFFER_SIZE = 8192;
}
```

**try-with-resource 복수 자원 처리 예시**

```jsx
// 코드 9-4 복수의 자원을 처리하는 try-with-resources - 짧고 매혹적이다! (49쪽)
static void copy(String src, String dst) throws IOException {
    try (InputStream   in = new FileInputStream(src);
         OutputStream out = new FileOutputStream(dst)) {
				...
		} 
		...
}
```

- try-with-resource 사용 시 위와 같이 좀 더 간결하게 복수 자원 처리가 가능하다.
    - 해당 방법을 사용하면 자원의 close()를 호출하는 것을 보장한다.

### try-with-resource 장점

try-with-resource이 유용한 이유 중 하나는 해당 구문에서 발생한 예외를 전부 표현해준다는 것이다.

```jsx
public class TopLine {
    // 코드 9-1 try-finally - 더 이상 자원을 회수하는 최선의 방책이 아니다! (47쪽)
    static String firstLineOfFile(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));
        try {
            return br.readLine();
        } finally {
            br.close();
        }
    }

    public static void main(String[] args) throws IOException {
        String path = args[0];
        System.out.println(firstLineOfFile(path));
    }
}
```

- 위 코드에서 exception이 발생할 수 있는 포인트가 두 군데(readLine(), close()) 존재한다.
- 만약 readLine() 처리 하는 중에 exception이 발생하고 finally 구문 처리하는데 close()에서도 exception이 발생한 경우 readLine(), close()에서 발생한 exception 중 어느 exception이 보여질까?
    - 위 코드에서는 close() 수행시 발생한 exception이 보여지게 된다. 다시 말해 마지막에 발생한 exception이 보여진다는 의미이다.
- try-with-resource에서 예외 표현 뿐 아니라 리소스 반납을 보장하게 된다.

```java
public class BadBufferedReader extends BufferedReader {
    public BadBufferedReader(Reader in, int sz) {
        super(in, sz);
    }

    public BadBufferedReader(Reader in) {
        super(in);
    }

    @Override
    public String readLine() throws IOException {
        throw new CharConversionException();
    }

    @Override
    public void close() throws IOException {
        throw new StreamCorruptedException();
    }
}

// 사용 예시
public class TopLine {
    // 코드 9-1 try-finally - 더 이상 자원을 회수하는 최선의 방책이 아니다! (47쪽)
    static String firstLineOfFile(String path) throws IOException {
        try (BufferedReader br = new BadBufferedReader(new FileReader(path))) {
            return br.readLine();
        }
    }

    public static void main(String[] args) throws IOException {
        System.out.println(firstLineOfFile("pom.xml"));
    }
}
```

- 위 코드에서 readLine() 호출 시 CharConversionException이 발생하게 되고 close() 호출 시 StreamCorruptedException이 발생하게 된다.
- 이때 try-with-resources를 사용하게 되면 자원 반납을 보장하고 해당 구문에서 발생한 예외를 모두 표현해주는 장점이 있다.
    - 후속 예외는 supressed로 표현하게된다.

## 완벽 공략

- `p48, 자바 퍼즐러 예외 처리 코드의 실수`

```java
public class Copy {
    private static final int BUFFER_SIZE = 8 * 1024;

    // 코드 9-2 자원이 둘 이상이면 try-finally 방식은 너무 지저분하다! (47쪽)
    static void copy(String src, String dst) throws IOException {
        InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst);
        try {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
                out.write(buf, 0, n);
        } finally {
            try {
                out.close();
            } catch (IOException e) {
                // TODO 이렇게 하면 되는거 아닌가?
            }

            try {
                in.close();
            } catch (IOException e) {
                // TODO 안전한가?
            }
        }
    }

    public static void main(String[] args) throws IOException {
        String src = args[0];
        String dst = args[1];
        copy(src, dst);
    }
}
```

- 위 코드의 문제점은 IOException을 반환하는 경우가 아니라 RuntimeException이 발생하는 경우 이다.
- 만약 out.close()수행 시 RuntimeException이 발생하면 in.close()는 수행하지 않게 된다.
- `P49, try-with-resources 바이트코드`
    - 어떻게 하면 자동으로 close()를 호출하고
    - 후속 예외를 보존할 수 있을까??

```java
// try-with-resources 사용 바이트 코드 에시
public class TopLine {
    public TopLine() {
    }

    static String firstLineOfFile(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));

        String var2;
        try {
            var2 = br.readLine();
        } catch (Throwable var5) {
            try {
                br.close();
            } catch (Throwable var4) {
                var5.addSuppressed(var4);
            }

            throw var5;
        }

        br.close();
        return var2;
    }
		...
}
```

- 리소스 반환 시 finally 블럭을 사용하지 않고 중첩된 try-catch 블럭을 사용한다.
- 예외 처리 시 addSuppressed()를 통해 후속 예외를 처리한다.