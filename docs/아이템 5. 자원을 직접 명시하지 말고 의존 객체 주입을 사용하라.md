# 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

## 핵심 정리

- `사용하는 자원에 따라 동작이 달라지는 클래스는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.`

```jsx
// 정적 유틸리티 클래스 방식
public class SpellChecker {
    // 자원을 직접 명시하는 예시
    // 테스트 코드 작성시 의존 객체인 Dictionary 활용 대한 유연함이 떨어진다.
    private static final KorDictionary dic = new KorDictionary();

    public SpellChecker() {
    }

    public static boolean isValid(String word) {
        return dic.contains(word);
    }

    public static List<String> suggestions(String typo) {
        return dic.closeWordsTo(typo);
    }
}

// 싱글톤 방식
public class SpellChecker {
    private final KorDictionary dic = new KorDictionary();

    private SpellChecker() {
    }

    public static final SpellChecker INSTANCE = new SpellChecker();

    public boolean isValid(String word) {
        return dic.contains(word);
    }

    public List<String> suggestions(String typo) {
        return dic.closeWordsTo(typo);
    }
}
```

- SpellChecker에 의존 객체(KorDictionary)를 명시적으로 정의하는 방식의 문제점은 SpellChecker를 생성할 때 마다. KorDictionary 인스턴스를 생성하는 문제점이 있다.

```jsx
class SpellCheckerTest {

    @Test
    void spellChecker() {
        boolean valid = SpellChecker.isValid("hello");
        assertTrue(valid);
    }
}
```

- 명시적으로 정의된 의존 객체로 인해 테스트 작성 시 유연함이 떨어지는 문제점이 있다.
- 의존 객체가 이미 컴파일 시점에 고정돼 있기 때문에 다형성 측면에서 유연함이 떨어진다.
- **리소스(의존 객체)에 따라 달라질 수 있는 코드라면 의존성 주입을 통해 해결하는 것이 좋다.**
    - ex) 언어별(국어사전, 영어사전) 사전의 기능을 사용할 필요가 있는 경우
- `의존 객체 주입이란 인스턴스를 생성할 때 필요한 자원을 넘겨주는 방식이다.`
- `이 방식의 변형으로 생성자에 자원 팩터리를 넘겨줄 수 있다.`
- `의존 객체 주입을 사용하면 클래스의 유연성, 재사용성, 테스트 용이성을 개선할 수 있다.`

```jsx
public interface Dictionary {
    boolean contains(String word);

    List<String> closeWordsTo(String typo);
}

public class SpellChecker {
    private final Dictionary dic;

    public SpellChecker(Dictionary dic) {
        this.dic = dic;
    }

    public boolean isValid(String word) {
        return dic.contains(word);
    }

    public List<String> suggestions(String typo) {
        return dic.closeWordsTo(typo);
    }
}
```

- 위 코드에서 주요한 점은 의존 객체를 외부로 부터 생성자로 전달 받는 부분과 의존 객체가 인터페이스로 정의했다는 점이다.

```jsx
class SpellCheckerTest {
    @Test
    void spellChecker() {
				// dictionary 객체를 외부에서 주입함으로써 유연함이 증가한다.
        SpellChecker spellChecker = new SpellChecker(new MockDictionary());
        assertFalse(spellChecker.isValid("bye"));
    }

    static class MockDictionary implements Dictionary {
        @Override
        public boolean contains(String word) {
            return false;
        }

        @Override
        public List<String> closeWordsTo(String typo) {
            return null;
        }
    }
}
```

## 완벽 공략

- `p29, 이 패턴의 쓸만한 변형으로 생성자에 자원 팩터리를 넘겨주는 방식이 있다.`

```jsx
// 팩토리 클래스
public class DictionaryFactory {
    public Dictionary get() {
        return new KorDictionary();
    }
}

public class SpellChecker {
    private final Dictionary dic;

    public SpellChecker(Dictionary dic) {
        this.dic = dic;
    }

		// 팩토리 클래스로 의존 객체 주입
    public SpellChecker(DictionaryFactory dicFactory) {
        this.dic = dicFactory.get();
    }
		...
}
```

- 중간 단계를 한번 더 추상화한 방식
- `p29, 자바 8에서 소개한 Supplier<T> 인터페이스가 팩터리를 표현한 완벽한 예다.`

```jsx
public class SpellChecker {
    private final Dictionary dic;

    public SpellChecker(Dictionary dic) {
        this.dic = dic;
    }

		// Supplier로 팩토리 클래스 대체하여 의존 객체 주입
    public SpellChecker(Supplier<Dictionary> dictionarySupplier) {
        this.dic = dictionarySupplier.get();
    }
		...
}
```

```jsx
class SpellCheckerTest {

    @Test
    void create_supplier() {
        // dictionary 객체를 외부에서 주입함으로써 유연함이 증가한다.
        SpellChecker spellChecker = new SpellChecker(() -> new MockDictionary());
        
        // method reference로 축약 가능하다.
        // SpellChecker spellChecker2 = new SpellChecker(MockDictionary::new);
        
        // 람다를 사용하면 팩토리 클래스를 활용할 수 있다.
        // SpellChecker spellChecker3 = new SpellChecker(DictionaryFactory::getKor);
        assertFalse(spellChecker.isValid("bye"));
    }
```

- `p29, 한정적 와일드카드 타입을 사용해 팩터리의 타입 매개변수를 제한해야 한다.`

```jsx
public SpellChecker(Supplier<? extends Dictionary> dictionarySupplier) {
    this.dic = dictionarySupplier.get();
}
```

- 추측컨데 구체적인 타입을 받는 Supplier라면 인터페이스를 통해 하위 타입을 받는 Supplier를 정의하라는 의미로 해석
- `p29, 팩터리 메소드 패턴`
- `p30, 의존 객체가 많은 경우에 Dagger, Guice, 스프링 같은 의존 객체 주입 프레임워크 도입을 고려할 수 있다.`

### 완벽 공략 14. 팩터리 메소드 패턴

`구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 정한다.`

- `새로운 Product를 제공하는 팩토리를 추가하더라도, 팩토리를 사용하는 클라이언트 코드는 변경할 필요가 없다.`

```jsx
//팩토리 인터페이스
public interface DictionaryFactory {
    Dictionary getDictionary();
}

//팩토리 구현 클래스
public class DefaultDictionaryFactory implements DictionaryFactory {
    @Override
    public Dictionary getDictionary() {
        return new KorDictionary();
    }
}

// 클라이언트
public class SpellChecker {
    private final Dictionary dictionary;

    public SpellChecker(DictionaryFactory dictionaryFactory) {
        this.dictionary = dictionaryFactory.getDictionary();
    }
}
```

- 인터페이스에 의존하는 형태는 클라이언트의 변경 없이 확장이 가능한 장점이 있다.(OCP)

### 완벽 공략 15. 스프링 IoC

`BeanFactory 또는 ApplicationContext`

- `Inversion of Control - 뒤짚힌 제어권`
    - `자기 코드에 대한 제어권을 자기 자신이 가지고 있지 않고 외부에서 제어하는 경우.`
    - `제어권? 인스턴스를 만들거나, 어떤 메소드를 실행하거나, 필요로하는 의존성을 주입받는 등…`
- `스프링 IoC 컨테이너 사용 장점`
    - `수많은 개발자에게 검증되었으며 자바 표준 스팩(@Inject)도 지원한다.`
    - `손쉽게 싱글톤 Scope을 사용할 수 있다.`
    - `객체 생성 (Bean) 관련 라이프사이클 인터페이스를 제공한다.`

```jsx
// POJO로 작성된 코드
public class SpellChecker {
    private final Dictionary dictionary;

    public SpellChecker(Dictionary dictionary) {
        this.dictionary = dictionary;
    }
}

//Spring IoC
@Configuration
@ComponentScan(basePackageClasses = AppConfig.class)
public class AppConfig {

    @Bean
    public SpellChecker spellChecker(Dictionary dictionary) {
        return new SpellChecker(dictionary);
    }

    @Bean
    public Dictionary dictionary() {
        return new SpringDictionary();
    }
}
```

- POJO로 작성된 코드(SpellChecker)를 설정(AppConfig)을 통해 스프링에서 빈으로 관리하도록 할 수 있다.
- 위 코드에서 주요한 점은 비즈니스 코드에 스프링 관련 의존성이 없다는 것이 핵심이다.
    - 의존 관계 설정 관련 클래스가 추가됐을 뿐이다.