# 아이템 8. finalizer와 cleaner 사용을 피하라

## 핵심정리

- `finalizer와 cleaner는 즉시 수행된다는 보장이 없다.`
- `finalizer와 cleaner는 실행되지 않을 수도 있다.`
    - 리소스가 반납이 안될 수 있다는 의미
- `finalizer 동작 중에 예외가 발생하면 정리 작업이 처리되지 않을 수도 있다.`
- `finalizer와 cleaner는 심각한 성능 문제가 있다.`
- `finalizer는 보안 문제가 있다.`

```java
public class FinalizerIsBad {

    @Override
    protected void finalize() throws Throwable {
        System.out.print("");
    }
}
```

- finalize()는 Object class에 정의된 메소드
- java 9 부터 deprecated 됐다.(사용을 자제하는 것이 좋다.)
- 큐에 들어있는 리소스를 정리하는 기능의 우선순위가 객체 생성보다 낮다.
    - 리소스 정리가 제대로 이뤄지지 않을 수 있다는 의미
- `**반납할 자원이 있는 클래스는 AutoCloseable을 구현하고 클라이언트에서 close()를 호출하거나 try-with-resource를 사용해야 한다.**`

**AutoCloseable**

```java
public class AutoClosableIsGood implements Closeable {
    private BufferedReader reader;

    public AutoClosableIsGood(String path) {
        try {
            this.reader = new BufferedReader(new FileReader(path));
        } catch (FileNotFoundException e) {
            throw new IllegalArgumentException(path);
        }
    }

    @Override
    public void close() {
        try {
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

**try-with-resource**

```java
public class App {

    public static void main(String[] args) {
        try (AutoClosableIsGood good = new AutoClosableIsGood("")) {
            // TODO 자원 반납 처리가 됨.
        }
    }
}
```

### Cleaner 사용법

- `**자원 반납용 안전망**으로 사용할 수 있다.`
    - `PhantomReference를 사용한다.`
    - `호출되리라는 보장이 없지만 없는 것 보다는 나을 수 있다.`

```java
public class BigObject {

    private List<Object> resource;

    public BigObject(List<Object> resource) {
        this.resource = resource;
    }

    public static class ResourceCleaner implements Runnable {
        private List<Object> resourceToClean;

        public ResourceCleaner(List<Object> resourceToClean) {
            this.resourceToClean = resourceToClean;
        }

        @Override
        public void run() {
            resourceToClean = null;
            System.out.println("cleaned up.");
        }
    }
}
```

- cleaner를 구현하려면 Runnable의 구현체로 생성해야하고 static 클래스로 선언해야한다.
- cleaner 객체는 정리하고자 하는 객체를 참조하고 있으면 안된다(여기선 BigObject)
    - cleaner에서 참고하게되면 다시 정리하고자 하는 메모리가 되살아날 수 있다.

```java
public class CleanerIsNotGood {

    public static void main(String[] args) throws InterruptedException {
        Cleaner cleaner = Cleaner.create();

        List<Object> resourceToCleanUp = new ArrayList<>();
        BigObject bigObject = new BigObject(resourceToCleanUp);
        cleaner.register(bigObject, new BigObject.ResourceCleaner(resourceToCleanUp));

        bigObject = null;
        System.gc();
        Thread.sleep(3000L);
    }
}
```

- 사용하는 방법은 phantom reference와 아주 유사하다.
    - phantom reference를 사용하여 만들어져 있기 때문
- `**네이티브 피어** 자원 회수`
    - `단, 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당한다.`
    - `네이티브 피어가 사용하는 자원을 즉시 회수해야 한다면 close() 메소드를 호출해야 한다.`

**안전망 사용 예시**

try-with-resource와 AutoCloseable를 구현했지만 만약의 상황으로 Cleaner를 안전망으로 구현한다는 의미

```java
// 코드 8-1 cleaner를 안전망으로 활용하는 AutoCloseable 클래스 (44쪽)
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();

    // 청소가 필요한 자원. 절대 Room을 참조해서는 안 된다!
    private static class State implements Runnable {
        int numJunkPiles; // Number of junk piles in this room

        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }

        // close 메서드나 cleaner가 호출한다.
        @Override public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }
    }

    // 방의 상태. cleanable과 공유한다.
    private final State state;

    // cleanable 객체. 수거 대상이 되면 방을 청소한다.
    private final Cleaner.Cleanable cleanable;

    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }

    @Override public void close() {
        cleanable.clean();
    }
}
```

```java
// cleaner 안전망을 갖춘 자원을 제대로 활용하는 클라이언트 (45쪽)
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
            System.out.println("안녕~");
        }
    }
}
```

- Adult는 try-with-resource와 AutoCloseable를 통해 자원은 해제하고 있다.

```java
// cleaner 안전망을 갖춘 자원을 제대로 활용하지 못하는 클라이언트 (45쪽)
public class Teenager {

    public static void main(String[] args) {
        new Room(99);
        System.out.println("Peace out");

        // 다음 줄의 주석을 해제한 후 동작을 다시 확인해보자.
        // 단, 가비지 컬렉러를 강제로 호출하는 이런 방식에 의존해서는 절대 안 된다!
        System.gc();
    }
}
```

- Teenager는 Room에 구현된 안전망 Cleaner를 통해 자원이 해제되는 예이다.

## 완벽 공략

- `p45, 정적(static)이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖는다.`

```java
public class OuterClass {

    private void hi() {
    }

    private void printFields() {
        Field[] declaredFields = InnerClass.class.getDeclaredFields();
        for (Field field : declaredFields) {
            System.out.println("field type:" + field.getType());
            System.out.println("field name:" + field.getName());
        }
    }

    class InnerClass {
        public void hello() {
            OuterClass.this.hi();
        }
    }

    public static void main(String[] args) {
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();

        System.out.println(innerClass);

        outerClass.printFields();
    }
}
```

- 중첩 클래스는 람다와 다르게 외부 객체의 필드, 메소드를 사용 하지 않아도 참조를 가지는 상태이다.
- `p45, 람다 역시 바깥 객체의 참조를 갖기 쉽다.`

```java
public class LambdaExample {
    private int value = 10;

		// 아래와 같이 정의하면 아래 람다 내부에서 LambdaExample를 참조가 가능해진다.
		// 아래와 같이 외부 필드를 사용하는 시점에 참조가 생기
    private Runnable instanceLambda = () -> {
        System.out.println(value);
    };

    public static void main(String[] args) {
        LambdaExample example = new LambdaExample();
        Field[] declaredFields = example.instanceLambda.getClass().getDeclaredFields();
        for (Field field : declaredFields) {
            System.out.println("field type: " + field.getType());
            System.out.println("field name: " + field.getName());
        }
    }
}
```

- 람다의 경우 외부 객체를 사용하게 되는 경우(캡쳐링 이라고 말한다.) 외부 객체에 대한 참조가 생기게 되는 것이고 사용하지 않으면 참조가 생기지 않는다.
- 람다를 static으로 정의하면 참조하지 않는다.
    - 외부 객체의 필드를 static으로 정의해도 참조하지 않게된다.

### 완벽 공략 22. Finalizer 공격

- `p42, Finalizer 공격`

`만들다 만 객체를 finalize 메소드에서 사용하는 방법`

- `Finalizer 공격`

```java
public class Account {
    private String accountId;

    public Account(String accountId) {
        this.accountId = accountId;

        if ("푸틴".equals(accountId)) {
            throw new IllegalArgumentException("푸틴은 계정을 막습니다.");
        }
    }

    public void transfer(BigDecimal amount, String to) {
        System.out.printf("transfer %f from %s to %s\n", amount, accountId, to);
    }
}

// Finalizer 공격을 위한 하위 클래스
public class BrokenAccount extends Account {
    public BrokenAccount(String accountId) {
        super(accountId);
    }

    @Override
    protected void finalize() throws Throwable {
        this.transfer(BigDecimal.valueOf(100), "hello");
    }
}
```

**Finalizer 공격 예시**

```java
@Test
void 푸틴_계정_Broker() throws InterruptedException {
    Account account = null;
    try {
        account = new BrokenAccount("푸틴");
    } catch (Exception e) {
        System.out.println("exception occur!");
    }
    System.gc();
    Thread.sleep(3000L);
}
```

- BrokenAccount 객체가 소멸하는 시점에 재정의된 finalize()에서 별도 로직이 수행될 위험성이 있다.
- `방어하는 방법`
    - `final 클래스로 만들거나`
    - `finalizer() 메소드를 오버라이딩 한 다음 final을 붙여서 하위 클래스에서 오버라이딩 할 수 없도록 막는다.`

```java
// finalizer 방어 1. final 클래스 정의
public final class Account {}

public class Account {
		// finalizer 방어 2. finalizer() 메소드를 오버라이딩
		// finalize 메소드를 final로 선언함으로서
		// 하위 객체에서 finalize를 사용하지 못하도록 해서 방어할 수 있다.
		@Override
		protected final void finalize() throws Throwable {
		    // 아무 행위를 하지 않아야 한다.
		}
}
```

### 완벽 공략 23. AutoClosable

- `p43, AutoClosable`

`try-with-resource를 지원하는 인터페이스`

```java
public class App {
    public static void main(String[] args) {
        try (AutoClosableIsGood good = new AutoClosableIsGood("")) {
            // TODO 자원 반납 처리가 됨.
        }
    }
}
```

- `void close() throws Exception`
    - `인터페이스에 정의된 메서드에서 Exception 타입으로 예외를 던지지만`
    - `실제 구현체에서는 구체적인 예외를 던지는 것을 추천하며`

```java
public class AutoClosableIsGood implements Closeable {
    private BufferedReader reader;
		...

    @Override
    public void close() throws IOException {
		    reader.close();
    }
}

// 클라이언트
public class App {
    public static void main(String[] args) {
        try (AutoClosableIsGood good = new AutoClosableIsGood("")) {
            // TODO 자원 반납 처리가 됨.
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 위 방식은 클라이언트에게 책임(exception 처리)을 전가하는 방식이다.
- `가능하다면 예외를 던지지 않는 것도 권장한다.`

```java
public class AutoClosableIsGood implements Closeable {
    private BufferedReader reader;
		...

    @Override
    public void close() {
        try {
            reader.close();
        } catch (IOException e) {
            throw e.printStackTrace();
        }
    }
}
```

- 클라이언트에게 책임을 전가하지 않고 내부에서 exception을 처리하도록 할 수 있다.

```java
public class AutoClosableIsGood implements Closeable {
    private BufferedReader reader;
		...

    @Override
    public void close() {
        try {
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

- 추가로 세부적인 방법으로 unchecked exception인 RuntimeException으로 wrapping하여 예외를 던지는 것도 가능하다.
- `Closeable 클래스와 차이점`

```java
package java.lang;

public interface AutoCloseable {
    void close() throws Exception;
}
```

- AutoCloseable의 close()를 구현할 땐, `idempotent` 하면 좋다(권장)

```java
package java.io;

public interface Closeable extends AutoCloseable {
    public void close() throws IOException;
}
```

- `IOException을 던지며`
- Closeable 의 close()를 구현할 땐, `반드시 idempotent 해야 한다.`
- `멱등성(idempotent)`: 몇번이 실행돼도 같은 결과를 반환해야하는 상태