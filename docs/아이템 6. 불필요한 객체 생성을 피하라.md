# 아이템 6. 불필요한 객체 생성을 피하라

## 핵심 정리

- `문자열`
    - `사실상 동일한 객체라서 매번 새로 만들 필요가 없다.`
    - `new String("자바") 을 사용하지 않고 문자열 리터럴 ("자바")을 사용해 기존에 동일한 문자열을 재사용하는 것이 좋다.`

```jsx
public class Strings {
    public static void main(String[] args) {
        String hello = "hello";
				// 권장하지 않는 방법
        String hello2 = new String("hello");
        String hello3 = "hello";

        System.out.println(hello == hello2); // false
        System.out.println(hello.equals(hello2)); // true
    }
}
```

- `정규식, Pattern`
    - `생성 비용이 비싼 객체라서 반복해서 생성하기 보다, 캐싱하여 재사용하는 것이 좋다.`

```jsx
// 값비싼 객체를 재사용해 성능을 개선한다. (32쪽)
public class RamanNumerals {
    // 코드 6-1 성능을 훨씬 더 끌어올릴 수 있다!
    static boolean isRomanNumeralSlow(String s) {
        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }

    // 코드 6-2 값비싼 객체를 재사용해 성능을 개선한다.
    private static final Pattern ROMAN = Pattern.compile(
            "^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeralFast(String s) {
        return ROMAN.matcher(s).matches();
    }

    public static void main(String[] args) {
        boolean result = false;
        long start = System.nanoTime();
        for (int j = 0; j < 100; j++) {
            //TODO 성능 차이를 확인하려면 xxxSlow 메서드를 xxxFast 메서드로 바꿔 실행해보자.
            result = isRomanNumeralSlow("MCMLXXVI");
        }
        long end = System.nanoTime();
        System.out.println(end - start);
        System.out.println(result);
    }
}
```

참고: 문자열을 매칭할 때 사용하는 알고리즘이 유한 상태 머신을 사용하는 알고리즘이다.

- `오토박싱 (auto boxing)`
    - `기본 타입(int)을 그게 상응하는 박싱된 기본 타입(Integer)으로 상호 변환해주는 기술.`
    - `기본 타입과 박싱된 기본 타입을 섞어서 사용하면 변환하는 과정에서 불필요한 객체가 생성될 수 있다.`
- `"객체 생성은 비싸니 피하라."는 뜻으로 오해하면 안 된다.`

```jsx
public class Sum {
    private static long autoBoxingSum() {
        Long sum = 0L;
        for (long i = 0; i <= Integer.MAX_VALUE; i++)
            sum += i;
        return sum;
    }

    private static long noneAutoBoxingSum() {
        long sum = 0L;
        for (long i = 0; i <= Integer.MAX_VALUE; i++)
            sum += i;
        return sum;
    }

    public static void main(String[] args) {
        System.out.println("=== autoboxing ===");
        long start = System.nanoTime();
        long x = autoBoxingSum();
        long end = System.nanoTime();
        System.out.println((end - start) / 1_000_000. + " ms.");
        System.out.println(x);

        System.out.println("=== none autoboxing ===");
        long start2 = System.nanoTime();
        long x2 = noneAutoBoxingSum();
        long end2 = System.nanoTime();
        System.out.println((end2 - start2) / 1_000_000. + " ms.");
        System.out.println(x2);
    }
}
```

## 완벽 공략

- `p33, 초기화 지연 기법 (아이템 83에서 다룸)`
- `p34, 방어적 복사 (아이템 50에서 다룸)`

### 완벽 공략 16. Deprecation

- `p31, 사용 자제 API (Deprecation)`

`클라이언트가 사용하지 않길 바라는 코드가 있다면…`

- **`사용 자제**를 권장하고 대안을 제시하는 방법이 있다.`
- `@Deprecated`
    - `컴파일시 경고 메시지를 통해 사용 자제를 권장하는 API라는 것을 클라이언트에 알려줄 수 있다.`
    - java 5부터 사용 가능
- `@deprecated`
    - `문서화(Javadoc)에 사용해, 왜 해당 API 사용을 지양하며, 그 대신 권장하는 API가 어떤 것인지 표기할 수 있다.`
    - `@Deprecated`된 기능에 대한 문서화를 해서 대체 기능에 대해 문서화하는 것을 권장
    - java 1.1부터 사용 가능

```jsx
public class Deprecation {
    private String name;
    // todo 애노테이션 프로세서 학습

    /**
     * @deprecated in favor of
     * {@link #Deprecation(String)}
     */
    @Deprecated(forRemoval = true, since = "1.7")
    public Deprecation() {
    }

    public Deprecation(String name) {
        this.name = name;
    }
}
```

### 완벽 공략 17. 정규 표현식

- `p32, 정규 표현식`

`내부적으로 Pattern이 쓰이는 곳`

- `String.matches(String regex)`
- `String.split(String regex)`
    - `대안, Pattern.compile(regex).split(str)`

```jsx
public class RegularExpression {
    private static final Pattern SPLIT_PATTERN = Pattern.compile(",");

    public static void main(String[] args) {
        long start = System.nanoTime();
        for (int j = 0; j < 10000; j++) {
            String name = "hello,effective,java";
            name.split(",");
//            SPLIT_PATTERN.split(name);
        }
        System.out.println(System.nanoTime() - start);
    }
}
```

regex를 하나의 문자로 split하는 경우 String.split()을 사용하는 것이 더 빠를 수 있다.

반대로 여러개의 문자로 split을 하는 경우 Pattern을 사용하는 것이 더 빠르다.

- `String.replace*(String regex, String replacement)`
    - `대안, Pattern.compile(regex).matcher(str).replaceAll(repl)`

replace도 상동

- `과제) 자바 정규표현식 Pattern 문법 학습하기`
- `참고 1) [https://docs.oracle.com/javase/tutorial/essential/regex/](https://docs.oracle.com/javase/tutorial/essential/regex/)`
- `참고 2) [https://regex101.com/](https://regex101.com/) 또는 [https://regexr.com/](https://regexr.com/)`

### 완벽 공략 18. 가비지 컬렉션

- `p32, 한 번 쓰고 버려져서 가비지 컬렉션 대상이 된다.`
    - 정규표현식용 Pattern 인스턴스

**기본 개념**

- `Mark, Sweep, Compact`
    - `Mark`: 앞으로 사라져도 되는 인스턴스인지 체크
    - `Sweep`: 필요없는 인스턴스를 지우는 작업
    - `Compact`: 비워진 공간 압축
- `Young Generation (Eden, S0, S1), Old Generation`
- `Minor GC, Full GC`
- `Throughput, **Latency (Stop-The-World)**, Footprint`
    - `Throughput`: 처리량
    - `Latency (Stop-The-World)`: 지연율
    - `Footprint`: 메모리, GC 알고리즘을 통해 필요로 하는 공간이 어느 정도인지
- `Serial, Parallel, CMS, G1, **ZGC**, Shenandoah`
- `참고) How to choose the best Java garbage collector`
    - [https://developers.redhat.com/articles/2021/11/02/how-choose-best-java-garbage-collector#](https://developers.redhat.com/articles/2021/11/02/how-choose-best-java-garbage-collector#)