# 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

## 핵심 정리

- `기존 인터페이스에 디폴트 메서드 구현을 추가하는 것은 위험한 일이다.`
    - `디폴트 메서드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 “삽입”될 뿐이다.`
    - `디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.`

```java

// 부모 클래스1
public interface MarkerInterface {

    default void hello() {
        System.out.println("hello interface");
    }

}

// 부모 클래스2
public class SuperClass {
    private void hello() {
        System.out.println("hello class");
    }
}
```

```java
public class SubClass extends SuperClass implements MarkerInterface {

    public static void main(String[] args) {
        SubClass subClass = new SubClass();
        subClass.hello();
    }
}
```

- 일반적으로 SubClass에서 hello()를 호출하면 MarkerInterface에 정의된 hello()를 호출할 듯 하지만 아아템 20에서 본 것과 같이 클래스가 인터페이스를 이기기 때문에 SuperClass의 hello()를 호출하게 되고 에러가 발생하게 된다.
    - jdk17에서도 발생하고 있음
- `인터페이스를 설계할 때는 세심한 주의를 기울여야 한다.`
    - `서로 다른 방식으로 최소한 세 가지는 구현을 해보자.`

## 완벽 공략

### 완벽 공략 38. ConcurrentModificationException

`현재 바뀌면 안되는 것을 수정할 때 발생하는 예외`

- `멀티 스레드가 아니라 싱글 스레드 상황에서도 발생할 수 있다. 가령, fail-fast 이터레이터를 사용해 콜렉션을 순회하는 중에 콜렉션을 변경하는 경우.`

```java
public class FailFast {

    public static void main(String[] args) {
//        List<Integer> numbers = List.of(1, 2, 3, 4, 5);

        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);

        // 이터레이터로 콜렉션을 순회하는 중에 Collection의 remove를 사용한다면...
//        for (Integer number : numbers) {
//            if (number == 3) {
//                numbers.remove(number);
//            }
//        }

        // 이터레이터의 remove 사용하기
//        for (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext();) {
//            Integer integer = iterator.next();
//            if(integer == 3) {
//                iterator.remove();
//            }
//        }

//        // 인덱스 사용하기
//        for (int i = 0; i < numbers.size() ; i++) {
//            if (numbers.get(i) == 3) {
//                numbers.remove(numbers.get(i));
//            }
//        }

        // removeIf 사용하기
				// 이터레이터의 remove를 사용하는 것과 동일한 방법이다.
//        numbers.removeIf(number -> number == 3);

        // 출력
        numbers.forEach(System.out::println);
    }
}
```

# References

- ConcurrentModificationException: [https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ConcurrentModificationException.html](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ConcurrentModificationException.html)