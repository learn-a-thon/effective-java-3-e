# 아이템 13. clone 재정의는 주의해서 진행하라

## 핵심 정리

- `clone 규약`
    - `x.clone() != x 반드시 true`
    - `x.clone().getClass() == x.getClass() 반드시 true`
    - `x.clone().equals(x) true가 아닐 수도 있다.`
- `불변 객체라면 다음으로 충분하다.`
    - `Cloenable 인터페이스를 구현하고`
    - `clone 메서드를 재정의한다. 이때 super.clone()을 사용해야 한다.`

```java
// 코드 13-1 가변 상태를 참조하지 않는 클래스용 clone 메서드 (79쪽)
@Override
public PhoneNumber clone() {
    try {
        return (PhoneNumber) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();  // 일어날 수 없는 일이다.
    }
}

// 일반적인 clone()
@Override
protected Object clone() throws CloneNotSupportedException {
    return super.clone();
}
```

- 상위 클래스의 메소드를 오버라이드 하는 경우
    - 접근제어자가 부모 메소드와 같거나 넓어야한다.
    - 반환 타입은 하위 타입이여도 가능하다.(책에서 공변 반환 타입? 라고 말함)
        - 구체적인 타입으로 반환하는 경우 사용하는 쪽에서 타입 캐스팅할 필요가 없다.

**생성자로 clone()를 재정의 하면 안된다.**

```java
// 부모 클래스
public class Item implements Cloneable {
    private String name;

    /**
     * 이렇게 구현하면 하위 클래스의 clone()이 깨질 수 있다. p78
     * @return
     */
    @Override
    public Item clone() {
        Item item = new Item();
        item.name = this.name;
        return item;
    }

		/**
     * 불변 객체인 경우 올바른 clone() 재정의 방법
     * @return
     */
    @Override
    public Item clone() {
        Item result = null;
        try {
            result = (Item) super.clone();
            return result;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
}

// 서브 클래스
public class SubItem extends Item implements Cloneable {
    private String name;

    @Override
    public SubItem clone() {
        return (SubItem) super.clone();
    }

    public static void main(String[] args) {
        SubItem item = new SubItem();
        SubItem clone = item.clone();

        System.out.println(clone != item);
        System.out.println(clone.getClass() == item.getClass());
        System.out.println(clone.equals(item));
    }
}
```

- clone()을 재정의 하려면 Cloneable을 선언해야한다.
- 생성자로 clone()을 재정의 하게 되면 하위 클래스에서 clone을 호출하는 경우 타입 변환이 이뤄지지 않아 에러가 발새할 수 있다.
- 불변 객체(값이 한번 설정되고 변경되지 않는 경우)의 경우 clone()에서 생성자 반환이 아닌 super.clone()을 호출하도록 하는 것이 clone()을 재정의하는 올바른 방법이다.
    - 가변 객체의 경우 더 복잡한 케이스를 고려해야한다.

### 핵심 정리: 가변 객체의 clone 구현하는 방법

- `접근 제한자는 public, 반환 타입은 자신의 클래스로 변경한다.`
- `super.clone을 호출한 뒤 필요한 필드를 적절히 수정한다.`
    - `배열을 복제할 때는 배열의 clone 메서드를 사용하라.`
    - `경우에 따라 final을 사용할 수 없을지도 모른다.`
    - `필요한 경우 deep copy를 해야한다.`
    - `super.clone으로 객체를 만든 뒤, 고수준 메서드를 호출하는 방법도 있다.`
        - map.put(), map.get()를 사용해 엔티티를 채워주는 방법
    - `오버라이딩 할 수 있는 메서드는 참조하지 않도록 조심해야 한다.`
        - 하위 클래스에서 오버라이딩하면 동작이 바뀔 수 있다.
        - 생성자에도 마찬가지로 참조하지 않도록 조심해야한다.
    - `상속용 클래스는 Cloneable을 구현하지 않는 것이 좋다.`
        - 만약 필요로 한다면 재정의가 불가하도록 strict하게 제한하는 방법을 고려한다.
    - `Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 동기화를 해야 한다.`
        - 굳이 이렇게 까지 clone을 사용할 이유는 없다.

```java
// Stack의 복제 가능 버전 (80-81쪽)
public class Stack implements Cloneable {
    private Object[] elements;

		// 코드 13-2 가변 상태를 참조하는 클래스용 clone 메서드
    // TODO stack -> elementsS[0, 1]
    // TODO copy -> elementsC[0, 1]
    // TODO elementsS[0] == elementsC[0]
    @Override 
    public Stack clone() {
        try {
            return (Stack) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

- Stack의 elements 필드를 변경될 수 있는 필드이다. 즉, Stack은 가변 객체이다.
- clone()을 살펴보면 불변 객체와 동일하게 super.clone()을 반환하고 있는데 가변 객체에서 위와 같이 clone을 재정의하는 경우 문제가 발생할 수 있다.

```java
public static void main(String[] args) {
    Object[] values = new Object[2];
    values[0] = new PhoneNumber(123, 456, 7890);
    values[1] = new PhoneNumber(321, 764, 2341);

    Stack stack = new Stack();
    for (Object arg : values)
        stack.push(arg);

    Stack copy = stack.clone();
		...
}
```

- 문제가 발생하는 이유는 stack 인스턴스를 clone()한 copy는 동일한 elements 필드를 참조하고 있기 때문이다.

```java
@Override
public Stack clone() {
    try {
        Stack result = (Stack) super.clone();
        // 가변 객체의 경우 가변 필드를 clone해야한다.
        result.elements = elements.clone();
        return result;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

- 그래서 위와 같이 가변 필드 또한 clone()이 필요하다.
- 문제는 stack과 copy 객체의 elements 인스턴스는 다르지만 elements 안의 값들은 여전히 동일한 참조 값이 들어있다.
    - 깊은 복사(deep copy)가 아닌 얕은 복사(shallow copy)이다.
    - 만약 elements의 값이 불변 객체라면 문제 없지만 가변 객체라면 문제가 발생할 수 있다.

**얕은 복사로 인해  위험성을 가진 코드 예시**

```java
public class HashTable implements Cloneable {

    private Entry[] buckets = new Entry[10];

    private static class Entry {
        final Object key;
        Object value;
				...
		}

		...
		/**
     * TODO hasTable -> entryH[],
     * TODO copy -> entryC[]
     * TODO entryH[0] == entryC[0]
     *
     * @return
     */
    @Override
    public HashTable clone() {
        HashTable result = null;
        try {
            result = (HashTable) super.clone();
            result.buckets = this.buckets.clone(); // p82, shallow copy 라서 위험하다.
            return result;
        } catch (CloneNotSupportedException e) {
            throw  new AssertionError();
        }
    }

		public static void main(String[] args) {
        HashTable hashTable = new HashTable();
        Entry entry = new Entry(new Object(), new Object(), null);
        hashTable.buckets[0] = entry;
        HashTable clone = hashTable.clone();
        System.out.println(hashTable.buckets[0] == entry);
        System.out.println(hashTable.buckets[0] == clone.buckets[0]);
    }
}
```

**깊은 복사 예시**

```java
public class HashTable implements Cloneable {

    private Entry[] buckets = new Entry[10];

    private static class Entry {
        final Object key;
        Object value;
        Entry next;

				...
				// 재귀적인 방법으로는 stackoverflow가 발생할 수 있다.
//        public Entry deepCopy() {
//            return new Entry(key, value, next == null ? null : next.deepCopy());
//        }

        public Entry deepCopy() {
            Entry result = new Entry(key, value, next);
            for (Entry p = result ; p.next != null ; p = p.next) {
                p.next = new Entry(p.next.key, p.next.value, p.next.next);
            }
            return result;
        }
    }

    /**
     * TODO hasTable -> entryH[],
     * TODO copy -> entryC[]
     * TODO entryH[0] != entryC[0]
     *
     * @return
     */
    @Override
    public HashTable clone() {
        HashTable result = null;
        try {
            result = (HashTable)super.clone();
            result.buckets = new Entry[this.buckets.length];

            for (int i = 0 ; i < this.buckets.length; i++) {
                if (buckets[i] != null) {
                    result.buckets[i] = this.buckets[i].deepCopy(); // p83, deep copy
                }
            }
            return result;
        } catch (CloneNotSupportedException e) {
            throw  new AssertionError();
        }
    }

    public static void main(String[] args) {
        HashTable hashTable = new HashTable();
        Entry entry = new Entry(new Object(), new Object(), null);
        hashTable.buckets[0] = entry;
        HashTable clone = hashTable.clone();
        System.out.println(hashTable.buckets[0] == entry);
        System.out.println(hashTable.buckets[0] == clone.buckets[0]);
    }
}
```

### 핵심 정리: clone 대신 권장하는 방법

- `"복사 생성자" 또는 변환 생성자, "복사 팩터리" 또는 변환 팩터리.`
- `생성자를 쓰지 않으며, 모호한 규약, 불필요한 검사 예외, final 용법 방해 등에서 벗어날 수 있다.`
    - clone()보다는 생성자를 쓰라는 의미
    - 정정 팩토리 메소드로 복사하는 메소드를 정의하는 것이 났다.
- `또 다른 큰 장점 중 하나로 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.`
    - `클라이언트가 복제본의 타입을 결정할 수 있다.`
- `읽어볼 것) Josh Bloch on Design, "Copy Constructor versus Cloning"`
    - [https://www.artima.com/articles/josh-bloch-on-design](https://www.artima.com/articles/josh-bloch-on-design)

## 완벽 공략

- `p80, **비검사 예외(UnChecked Exception)**였어야 했다는 신호다.`
- `p81. HashTable과 LinkedList`
    - [참고] hashMap과 linkedList: [https://lordofkangs.tistory.com/78](https://lordofkangs.tistory.com/78)
- `p83, 깊은 복사 (deep copy)`
- `p83, 리스트가 길면 **스택 오버플로**를 일으킬 위험이 있기 때문이다.`
- `p85, clone 메서드 역시 적절히 **동기화**해줘야 한다.`
- `p86, TreeSet`

### 완벽 공략 29. UncheckedException

`왜 우리는 비검사 예외를 선호하는가?`

- `컴파일 에러를 신경쓰지 않아도 되며,`
- `try-catch로 감싸거나`
- `메서드 선언부에 선언하지 않아도 된다.`
- `그렇다면 우리는 비검사 예외만 쓰면 되는걸까? 검사 예외는 왜 있는것일까?`

```java
public class MyException extends Exception {
}
```

- Exception을 상속한 클래스는 checkedException 이다.
- RuntimeException, Error 둘 다 UncheckedException이다.

### 완벽 공략 29. UncheckedException

`그렇다면 우리는 비검사 예외만 쓰면 되는걸까?`

- `왜 잡지 않은 예외를 메서드에 선언해야 하는가?`
    - `메서드에 선언한 예외는 프로그래밍 인터페이스의 일부다. 즉, 해당 메서드를 사용하는 코드가 반드시 알아야 하는 정보다. 그래야 해당 예외가 발생했을 상황에 대처하는 코드를 작성할 수 있을테니까.`
- `비검사 예외는 그럼 왜 메서드에 선언하지 않아도 되는가?`
    - `비검사 예외는 어떤 식으로든 처리하거나 복구할 수 없는 경우에 사용하는 예외다. 가령, 숫자를 0으로 나누거나, null 레퍼런스에 메서드를 호출하는 등.`
    - `이런 예외는 프로그램 전반에 걸쳐 어디서든 발생할 수 있기 때문에 이 모든 비검사 예외를 메서드에 선언하도록 강제한다면 프로그램의 명확도가 떨어진다.`

### 완벽 공략 29. UncheckedException

`언제 어떤 예외를 써야 하는가?`

- `단순히 처리하기 쉽고 편하다는 이유만으로 RuntimeException을 선택하지는 말자.`
- `가이드라인: 클라이언트가 해당 예외 상황을 복구할 수 있다면 검사 예외를 사용하고, 해당 예외가 발생했을 때 아무것도 할 수 없다면, 비검사 예외로 만든다.`
- [`https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html`](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)

### 완벽 공략 30. TreeSet

`AbstractSet을 확장한 정렬된 컬렉션`

- `엘리먼트를 추가한 순서는 중요하지 않다.`
- `엘리먼트가 지닌 자연적인 순서(natural order)에 따라 정렬한다.`
- `오름차순으로 정렬한다.`
- `스레드 안전하지 않다.`

```java
public class TreeSetExample {

    public static void main(String[] args) {
//        TreeSet<Integer> numbers = new TreeSet<>();
//        numbers.add(10);
//        numbers.add(4);
//        numbers.add(6);

        TreeSet<PhoneNumber> numbers = new TreeSet<>(Comparator.comparingInt(PhoneNumber::hashCode));
        Set<PhoneNumber> phoneNumbers = Collections.synchronizedSet(numbers);
        phoneNumbers.add(new PhoneNumber(123, 456, 780));
        phoneNumbers.add(new PhoneNumber(123, 456, 7890));
        phoneNumbers.add(new PhoneNumber(123, 456, 789));

        for (PhoneNumber number : numbers) {
            System.out.println(number);
        }
    }
}
```

- `과제) 이진 검색 트리, 레드 블랙 트리에 대해 학습하세요.`