# 아이템 27. 비검사 경로를 제거하라

## 핵심 정리

- `“비검사 (unchecked) 경고”란?`
    - `컴파일러가 타입 안정성을 확인하는데 필요한 정보가 충분치 않을 때 발생시키는 경고.`

```java
public class SetExample {

    public static void main(String[] args) {
        Set names = new HashSet(); // 컴파일 경고!

        Set<String> strings = new HashSet<>();
    }
}
```

- java7 부터 다이아몬드 연산자를 생략해도된다.
    - `Set<String> names = new HashSet<String>()` 와 같이 타입을 반복하지 않아도 된다는 의미 new HashSet<>()
- `할 수 있는 한 모든 비검사 경고를 제거하라.`
- `경고를 제거할 수 없지만 안전하다고 확신한다면 @SuppressWarnings(“unchecked”) 애노테이션을 달아 경고를 숨기자.`
- `@SuppressWarnings 애너테이션은 항상 가능한 한 좁은 범위에 적용하자.`
- `@SuppressWarnings(“unchecked”) 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 한다.`

```java
public class ListExample {

    private int size;

    Object[] elements;

    public <T> T[] toArray(T[] a) {
        if (a.length < size) {
            /**
             * 이 애노테이션을 왜 여기서 선언했는지..
             */
            @SuppressWarnings("unchecked")
            T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());
            return result;
        }
        System.arraycopy(elements, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }
}
```

- 내가 이미 알고 있는 경고라면 @SuppressWarnings를 선언해서 경고를 없애주자.

## 완벽공략

### 완벽 공략 41. 애너테이션

`자바 애너테이션을 정의하는 방법`

- `@Retention: 애노테이션의 정보를 얼마나 오래 유지할 것인가.`
    - `Runtime, Source, Class`
- `@Target: 애노테이션을 사용할 수 있는 위치.`
    - `Type, Field, Method, Parameter, …`

```java
@Retention(RetentionPolicy.SOURCE)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface MyAnnotation {
}
```

- `@Documented`: javadoc 생성시 해당 애너테이션를 포함해서 생성하게 한다.
    - Retention.Source로 선언하게되면 리플랙션, 바이트코드 조작을 통해 정보를 가져오는 것이 불가하다.
        - 그 외 Runtime, Class는 리플랙션, 바이트코드 조작으로 정보를 가져오는 것이 가능하다는 의미

```java
@MyAnnotation
public class MyClass {

    @MyAnnotation
    public static void main(String[] args) {
        Arrays.stream(MyClass.class.getAnnotations()).forEach(System.out::println);
    }
}
```