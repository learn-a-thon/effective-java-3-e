# 아이템 24. 멤버 클래스는 되도록 static으로 만들라

## 핵심 정리

- `정적 멤버 클래스`
    - `바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스.`
        - `예) Calculator.Operation.PLUS`

```java
// 정적 멤버 클래스
public class OutterClass {

    private static int number = 10;

    static private class InnerClass {
        void doSomething() {
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        InnerClass innerClass = new InnerClass();
        innerClass.doSomething();
    }
}
```

- 내부 클래스가 외부 클래스의 참조를 가지고 있지 않는다.
- `비정적 멤버 클래스`
    - `바깥 클래스의 인스턴스와 암묵적으로 연결된다.`
    - `어댑터를 정의할 때 자주 쓰인다.`
    - `멤버 클래스에서 바깥 인스턴스를 참조할 필요가 없다면 무조건 정적 멤버 클래스로 만들자.`

```java
public class OutterClass {
    private int number = 10;

    void printNumber() {
        InnerClass innerClass = new InnerClass();
    }

    private class InnerClass {
        void doSomething() {
            System.out.println(number);
            OutterClass.this.printNumber();
        }
    }

    public static void main(String[] args) {
        InnerClass innerClass = new OutterClass().new InnerClass();
        innerClass.doSomething();
    }
}
```

- InnerClass가 OutterClass의 참조를 가진다
- OutterClass가 생성된 후에 InnerClass를 생성할 수 있다.
    - 불필요하게 OutterClass 생성 이후에 생성해야할지 고민해볼 필요가 있고 불필요하다면 정적 내부 클래스로 정의하는 것이 좋다.
- 외부 클래스의 참조가 없는 경우에 정적 내부 클래스로 정의하는 것을 권장한다.
- `익명 클래스`
    - `바깥 클래스의 멤버가 아니며, 쓰이는 시점과 동시에 인스턴스가 만들어진다.`
    - `비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.`
    - `자바에서 람다를 지원하기 전에 즉석에서 작은 함수 객체나 처리 객체를 만들 때 사용했다.`
    - `정적 팩터리 메서드를 만들 때 사용할 수도 있다.`

```java
// 코드 20-1 골격 구현을 사용해 완성한 구체 클래스 (133쪽)
public class IntArrays {
    static List<Integer> intArrayAsList(int[] a) {
        Objects.requireNonNull(a);

        // 다이아몬드 연산자를 이렇게 사용하는 건 자바 9부터 가능하다.
        // 더 낮은 버전을 사용한다면 <Integer>로 수정하자.
        return new AbstractList<>() {
            @Override
            public Integer get(int i) {
                return a[i];  // 오토박싱(아이템 6)
            }

            @Override
            public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val;     // 오토언박싱
                return oldVal;  // 오토박싱
            }

            @Override
            public int size() {
                return a.length;
            }
        };
    }

    public static void main(String[] args) {
        int[] a = new int[10];
        for (int i = 0; i < a.length; i++)
            a[i] = i;

        List<Integer> list = intArrayAsList(a);
        Collections.shuffle(list);
        System.out.println(list);
    }
}
```

- `지역 클래스`
    - `가장 드물게 사용된다.`
    - `지역 변수를 선언하는 곳이면 어디든 지역 클래스를 정의해 사용할 수 있다.`
    - `가독성을 위해 짧게 작성해야 한다.`

```java
public class MyClass {
    private int number = 10;

    void doSomething() {
				// 로컬 클래스
        class LocalClass {
            private void printNumber() {
                System.out.println(number);
            }
        }

        LocalClass localClass = new LocalClass();
        localClass.printNumber();
    }

    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        myClass.doSomething();
    }
}
```

## 완벽 공략

### 완벽 공략 39. 어댑터 패턴

- `p147. 어댑터`

`기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴`

- `클라이언트가 사용하는 인터페이스를 따르지 않는 기존 코드를 재사용할 수 있게
해준다.`

```java
// 어댑터 클래스
public class MySet<E> extends AbstractSet<E> {
    @Override
    public Iterator<E> iterator() {
        return new MyIterator();
    }

    @Override
    public int size() {
        return 0;
    }

    private class MyIterator implements Iterator<E> {

        @Override
        public boolean hasNext() {
            return false;
        }

        @Override
        public E next() {
            return null;
        }
    }
}
```

**어댑터 패턴 사용 예시**

```java
public class AdapterInJava {

    public static void main(String[] args) {
        try (InputStream is = new FileInputStream("number.txt");
             InputStreamReader isr = new InputStreamReader(is);
             BufferedReader reader = new BufferedReader(isr)) {
            while (reader.ready()) {
                System.out.println(reader.readLine());
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

# References

- spring 내부 클래스, 정적 내부 클래스의 빈 생성: [https://www.inflearn.com/questions/803187/학습-테스트-작성-시-정적-클래스-관련질문](https://www.inflearn.com/questions/803187/%ED%95%99%EC%8A%B5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%91%EC%84%B1-%EC%8B%9C-%EC%A0%95%EC%A0%81-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B4%80%EB%A0%A8%EC%A7%88%EB%AC%B8)