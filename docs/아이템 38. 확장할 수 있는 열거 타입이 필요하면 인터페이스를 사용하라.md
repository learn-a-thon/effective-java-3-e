# 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

```java
// 타입 안전 열거 패턴
public class TypesafeOperation {
    private final String type;
    private TypesafeOperation(String type) {
        this.type = type;
    }

    public String toString() {
        return type;
    }
}

public static final TypesafeOperation PLUS = new TypesafeOperation("+");
public static final TypesafeOperation MINUS = new TypesafeOperation("-");
public static final TypesafeOperation TIMES = new TypesafeOperation("*");
public static final TypesafeOperation DIVIDE = new TypesafeOperation("/");
```

열거 타입은 거의 모든 상황에서 **타입 안전 열거 패턴(typesafe enum pattern)**보다 우수하다. 단, 타입 안전 열거 패턴은 확장할 수 있으나 열거 타입은 그럴 수 없다.(열거 타입은 상속이 불가하다는 의미로 이해)

열거 타입은 확장하는 것은 좋지 않다.

- 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 반대는 성립하지 않는다.
- 기반 타입과 확장된 타입들의 원소 모두를 순회할 방법이 마땅치 않다.
- API가 제공하는 기본 연산 외에 사용자 확장 연산을 추가할 수 있도록 열어줘야 할 수 도 있다.

```java
// 코드 38-1 인터페이스를 이용해 확장 가능 열거 타입을 흉내 냈다. (232쪽)
public interface Operation {
    double apply(double x, double y);
}

// 코드 38-1 인터페이스를 이용해 확장 가능 열거 타입을 흉내 냈다. - 기본 구현 (233쪽)
public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        public double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES("*") {
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            return x / y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }
}

// 코드 38-2 확장 가능 열거 타입 (233-235쪽)
public enum ExtendedOperation implements Operation {
    EXP("^") {
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    },
    REMAINDER("%") {
        public double apply(double x, double y) {
            return x % y;
        }
    };
    private final String symbol;

    ExtendedOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }

		// 열거 타입의 Class 객체를 이용해 확장된 열거 타입의 모든 원소를 사용하는 예 (234쪽)
    public static void main(String[] args) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        test(ExtendedOperation.class, x, y);
    }
    private static <T extends Enum<T> & Operation> void test(Class<T> opEnumType, double x, double y) {
        for (Operation op : opEnumType.getEnumConstants()) {
            System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
        }
    }
}
```

- 열거 타입의 임의의 인터페이스를 구현하는 것으로 위 문제를 해결할 수 있다.
- test 메서드에 class 리터럴은 한정적 타입 토큰(아이템 33)역할을 한다.
- opEnumType의 타입(<T extends Enum<T> & Operation>)의 경우 Class 객체가 열거 타입인 동시에 Operation의 하위 타입이어야 한다는 의미

```java
// 컬렉션 인스턴스를 이용해 확장된 열거 타입의 모든 원소를 사용하는 예 (235쪽)
public static void main(String[] args) {
    double x = Double.parseDouble(args[0]);
    double y = Double.parseDouble(args[1]);
    test(Arrays.asList(ExtendedOperation.values()), x, y);
}

private static void test(Collection<? extends Operation> opSet, double x, double y) {
    for (Operation op : opSet) {
        System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
		}
}
```

- 위 코드는 Class 객체 대신 한정적 와일드카드 타입(아이템 31)인 Collection<? extends Operation>을 넘기는 방법이다.
- 특정 연산에서 EnumSet과 EnumMap을 사용하지 못한다.

인터페이스를 이용해 확장 가능한 열거 타입을 흉내 내는 방식에 한 가지 문제가 있다.

- 열거 타입끼리 구현을 상속할 수 없다.

이에 대한 대안으로 인터페이스에 **디폴트 메소드(아이템 20)**을 추가하는 방안이 있긴하다.

자바 라이브러리 중 위 내용을 적용한 예시가 있다. java.nio.file.LinkOption 열거타입은 CopyOption과 OpenOption 인터페이스를 구현했으니 참고

```java
package java.nio.file;

/**
 * An object that configures how to open or create a file.
 *
 * <p> Objects of this type are used by methods such as {@link
 * Files#newOutputStream(Path,OpenOption[]) newOutputStream}, {@link
 * Files#newByteChannel newByteChannel}, {@link
 * java.nio.channels.FileChannel#open FileChannel.open}, and {@link
 * java.nio.channels.AsynchronousFileChannel#open AsynchronousFileChannel.open}
 * when opening or creating a file.
 *
 * <p> The {@link StandardOpenOption} enumeration type defines the
 * <i>standard</i> options.
 *
 * @since 1.7
 */

public interface OpenOption {
}
```

```java
package java.nio.file;

/**
 * An object that configures how to copy or move a file.
 *
 * <p> Objects of this type may be used with the {@link
 * Files#copy(Path,Path,CopyOption[]) Files.copy(Path,Path,CopyOption...)},
 * {@link Files#copy(java.io.InputStream,Path,CopyOption[])
 * Files.copy(InputStream,Path,CopyOption...)} and {@link Files#move
 * Files.move(Path,Path,CopyOption...)} methods to configure how a file is
 * copied or moved.
 *
 * <p> The {@link StandardCopyOption} enumeration type defines the
 * <i>standard</i> options.
 *
 * @since 1.7
 */

public interface CopyOption {
}
```

```java
package java.nio.file;

/**
 * Defines the options as to how symbolic links are handled.
 *
 * @since 1.7
 */
public enum LinkOption implements OpenOption, CopyOption {
    /**
     * Do not follow symbolic links.
     *
     * @see Files#getFileAttributeView(Path,Class,LinkOption[])
     * @see Files#copy
     * @see SecureDirectoryStream#newByteChannel
     */
    NOFOLLOW_LINKS;
}
```