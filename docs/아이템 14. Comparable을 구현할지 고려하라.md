# 아이템 14. Comparable을 구현할지 고려하라

## 핵심 정리

### CompareTo 규약

- `Object.equals에 더해서 순서까지 비교할 수 있으며 Generic을 지원한다.`
- `자기 자신이 (this)이 compareTo에 전달된 객체보다 작으면 음수, 같으면 0, 크다면 양수를 리턴한다.`
- `반사성, 대칭성, 추이성을 만족해야 한다.`
- `반드시 따라야 하는 것은 아니지만 x.compareTo(y) == 0이라면 x.equals(y)가 true여야 한다.`

```java
// p89, compareTo가 0이라면 equals는 true여야 한다. (아닐 수도 있고..)
BigDecimal oneZero = new BigDecimal("1.0");
BigDecimal oneZeroZero = new BigDecimal("1.00");
System.out.println(oneZero.compareTo(oneZeroZero)); // Tree, TreeMap
System.out.println(oneZero.equals(oneZeroZero)); // 순서가 없는 콜렉션
```

equals()는 소수점 이하(scale)까지 비교하고 compareTo()는 정수 부분만 비교하는 듯하다.

### CompareTo 구현 방법

- `자연적인 순서를 제공할 클래스에 implements Compratable<T> 을 선언한다.`
- `compareTo 메서드를 재정의한다.`
- `comprareTo 메서드 안에서 기본 타입은 박싱된 기본 타입의 compare을 사용해 비교한다.`
- `핵심 필드가 여러 개라면 비교 순서가 중요하다. 순서를 결정하는데 있어서 가장 중요한 필드를 비교하고 그 값이 0이라면 다음 필드를 비교한다.`

```java
public class Point implements Comparable<Point>{

    final int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    public int compareTo(Point point) {
        int result = Integer.compare(this.x, point.x);
        if (result == 0) {
            result = Integer.compare(this.y, point.y);
        }
        return result;
    }
}
```

- `기존 클래스를 확장하고 필드를 추가하는 경우 compareTo 규약을 지킬 수 없다.`

```java
// 확장하는 경우 compareTo 규약을 지킬 수 없다.
public class NamedPoint extends Point {

    final private String name;
		...
}
```

대안으로 Comparator를 구현해 볼 수 있다.

```java
public static void main(String[] args) {
    NamedPoint p1 = new NamedPoint(1, 0, "hello");
    NamedPoint p2 = new NamedPoint(1, 0, "world");

    Set<NamedPoint> points = new TreeSet<>(new Comparator<NamedPoint>() {
        @Override
        public int compare(NamedPoint p1, NamedPoint p2) {
            int result = Integer.compare(p1.getX(), p2.getX());
            if (result == 0) {
                result = Integer.compare(p1.getY(), p2.getY());
            }
            if (result == 0) {
                result = p1.name.compareTo(p2.name);
            }
            return result;
        }
    });

    points.add(p1);
    points.add(p2);

    System.out.println(points);
}
```

- `Composition을 활용할 것.`
    - 상속 말고 합성을 활용해볼 것

```java
public class NamedPoint implements Comparable<NamedPoint> {

    private final Point point;
    private final String name;

    public NamedPoint(Point point, String name) {
        this.point = point;
        this.name = name;
    }

    public Point getPoint() {
        return this.point;
    }

    @Override
    public int compareTo(NamedPoint namedPoint) {
        int result = this.point.compareTo(namedPoint.point);
        if (result == 0) {
            result = this.name.compareTo(namedPoint.name);
        }
        return result;
    }
}
```

- `자바 8부터 함수형 인터페이스, 람다, 메서드 레퍼런스와 Comprator가 제공하는 기본 메서드와 static 메서드를 사용해서 Comprator를 구현할 수 있다.`
- `Comparator가 제공하는 메서드 사용하는 방법`
- `Comparator의 static 메서드를 사용해서 Comparator 인스턴스 만들기`
- `인스턴스를 만들었다면 default 메서드를 사용해서 메서드 호출 이어가기 (체이닝)`

```java
private static final Comparator<PhoneNumber> COMPARATOR =
            comparingInt((PhoneNumber pn) -> pn.areaCode)
                    .thenComparingInt(pn -> pn.getPrefix())
                    .thenComparingInt(pn -> pn.lineNum);
```

- `static 메서드와 default 메소드의 매개변수로는 람다 표현식 또는 메서드 레퍼런스를 사용할 수 있다.`

```java
private static final Comparator<PhoneNumber> COMPARATOR =
            comparingInt((PhoneNumber pn) -> pn.areaCode)
                    .thenComparingInt(pn -> pn.getPrefix())
                    .thenComparingInt(PhoneNumber::getLineNum);
```

## 완벽 공략

- `p90, 제네릭 인터페이스이므로 compareTo 메서드의 인수 타입은 컴파일 타임에 정해진다.`

```java
public final class PhoneNumber implements Cloneable, Comparable<PhoneNumber> {
```

- `p92, 자바의 타입 추론 능력이 이 상황에서 타입을 알아낼 만큼…`

```java
private static final Comparator<PhoneNumber> COMPARATOR = 
		comparingInt((PhoneNumber pn) -> pn.areaCode)
		.thenComparingInt(pn -> pn.getPrefix())
```

comparingInt((PhoneNumber pn) -> pn.areaCode) 에서는 타입 추론을 제대로 못하기 때문에 타입을 명시해 준 것이다.

thenComparingInt(pn -> pn.getPrefix()) 요 부분에서는 자바가 타입 추론을 잘한 것임

```java
var rnd = ThreadLocalRandom.current();
```

- `p93. 이 방식은 정수 오버플로를 일으키거나`

```java
static Comparator<Object> hashCodeOrder = new Comparator<>() {
		public int compare(Object o1, Object o2) {
				return o1.hashCode() - o2.hashCode();
		}
}
```

위 방식이 왜 문제있는지는 다음 정수 예시를 통해 알 수 있다.

```java
public class IntOverflow {

    public static void main(String[] args) {
        System.out.println(-2147483648 - 10); // 음의 정수의 끝은 양의 정수의 최대값이다.

				// 다음 방식을 사용하는 것을 권장한다.
        System.out.println(Integer.compare(-2147483648, 10));
    }
}
```

- `p93, IEEE 754 부동소수점 계산 방식에 따른 오류를 낼 수 있다.`

```java
public class DecimalIsNotCorrect {

    public static void main(String[] args) {
        int i = 1;
        double d = 0.1;
        System.out.println(i - d * 9);

				// 권장 하는 방법
        BigDecimal bd = BigDecimal.valueOf(0.1);
        System.out.println(BigDecimal.valueOf(1).min(bd.multiply(BigDecimal.valueOf(9))));
    }
}
```