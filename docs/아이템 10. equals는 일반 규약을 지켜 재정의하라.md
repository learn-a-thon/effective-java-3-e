# 아이템 10. equals는 일반 규약을 지켜 재정의하라

## 핵심 정리

### 핵심 정리 1. equals가 필요 없는 경우

`equals를 재정의 하지 않는 것이 최선`

- `다음의 경우에 해당한다면 equals를 재정의 할 필요가 없다.`
- `각 인스턴스가 본질적으로 고유하다.`
    - 싱글톤, enum
- `인스턴스의 ‘논리적 동치성’을 검사할 필요가 없다.`
    - 값 자체를 검사할 필요가 없는 경우
- `상위 클래스에서 재정의한 equals가 하위 클래스에도 적절하다.`
    - List, Set의 재정의 하는 경우 상위 클래스에서 이미 정의돼 있기 때문
- `클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이
없다.`

### 핵심 정리 2. equals 규약 - 반사성, 대칭성

- `반사성: A.equals(A) == true`
- `대칭성: A.equals(B) == B.equals(A)`
    - `CaseInsensitiveString`

```java
// 코드 10-1 잘못된 코드 - 대칭성 위배! (54-55쪽)
public final class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }

		// 대칭성 위배!
    @Override 
		public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase(
                    ((CaseInsensitiveString) o).s);
        if (o instanceof String)  // 한 방향으로만 작동한다!
            return s.equalsIgnoreCase((String) o);
        return false;
    }

    // 문제 시연 (55쪽)
    public static void main(String[] args) {
        CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
//        CaseInsensitiveString cis2 = new CaseInsensitiveString("polish");
        String polish = "polish";
        System.out.println(cis.equals(polish)); // true
//        System.out.println(cis2.equals(cis)); // false

        List<CaseInsensitiveString> list = new ArrayList<>();
        list.add(cis);

        System.out.println(list.contains(polish));
    }

    // 수정한 equals 메서드 (56쪽)
//    @Override public boolean equals(Object o) {
//        return o instanceof CaseInsensitiveString &&
//                ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
//    }
}
```

equals에 `if (o instanceof String)`와 같이 파라미터가 String인 경우만 고려한다면 반대의 경우인 `System.out.println(cis2.equals(cis));` 를 수행하면 String은 CaseInsensitiveString를 전혀 모르기 때문에 false가 반환되고 대칭성이 깨지게 되는 것이다. 

### 핵심 정리 3. equals 규약 - 추이성

- `추이성: A.equals(B) && B.equals(C), A.equals(C)`
    - `Point, ColorPoint(inherit), CounterPointer, ColorPoint(comp)`

```java
// 단순한 불변 2차원 정수 점(point) 클래스 (56쪽)
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override 
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof Point)) {
            return false;
        }

        Point p = (Point) o;
        return p.x == x && p.y == y;
    }

    // 잘못된 코드 - 리스코프 치환 원칙 위배! (59쪽)
//    @Override public boolean equals(Object o) {
//        if (o == null || o.getClass() != getClass())
//            return false;
//        Point p = (Point) o;
//        return p.x == x && p.y == y;
//    }

    // 아이템 11 참조
    @Override 
    public int hashCode()  {
        return 31 * x + y;
    }
    
    public static void main(String[] args) {
        Point point = new Point(1, 2);
        List<Point> points = new ArrayList<>();
        points.add(point);
        System.out.println(points.contains(new Point(1, 2)));
    }
}
```

```java
// Point에 값 컴포넌트(color)를 추가 (56쪽)
public class ColorPoint extends Point {
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    // 코드 10-2 잘못된 코드 - 대칭성 위배! (57쪽)
//    @Override public boolean equals(Object o) {
//        if (!(o instanceof ColorPoint))
//            return false;
//        return super.equals(o) && ((ColorPoint) o).color == color;
//    }

    // 코드 10-3 잘못된 코드 - 추이성 위배! (57쪽)
    @Override public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;

        // o가 일반 Point면 색상을 무시하고 비교한다.
        if (!(o instanceof ColorPoint))
            return o.equals(this);

        // o가 ColorPoint면 색상까지 비교한다.
        return super.equals(o) && ((ColorPoint) o).color == color;
    }

    public static void main(String[] args) {
        // 첫 번째 equals 메서드(코드 10-2)는 대칭성을 위배한다. (57쪽)
//        Point p = new Point(1, 2);
//        ColorPoint cp = new ColorPoint(1, 2, Color.RED);
//        System.out.println(p.equals(cp) + " " + cp.equals(p));

        // 두 번째 equals 메서드(코드 10-3)는 추이성을 위배한다. (57쪽)
        ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
        Point p2 = new Point(1, 2);
        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
        System.out.printf("%s %s %s%n",
                          p1.equals(p2), p2.equals(p3), p1.equals(p3));
    }
}
```

위 코드에서 ColorPoint 클래스는 Point 클래스를 상속받은 자식 클래스이다. 이렇게 상속 구조에서 equals 를 수행하면 대칭성, 추이성이 깨질 수 있는 문제점이 있다.

아래 코드는 대칭성이 깨지는 문제점을 가진 코드이다.

```java
// 코드 10-2 잘못된 코드 - 대칭성 위배! (57쪽)
@Override 
public boolean equals(Object o) {
		if (!(o instanceof ColorPoint))
        return false;
    return super.equals(o) && ((ColorPoint) o).color == color;
}

// 사용 예시
public static void main(String[] args) {
    // 첫 번째 equals 메서드(코드 10-2)는 대칭성을 위배한다. (57쪽)
    Point p = new Point(1, 2);
    ColorPoint cp = new ColorPoint(1, 2, Color.RED);
    System.out.println(p.equals(cp) + " " + cp.equals(p)); // true false
}
```

ColorPoint에 위와 같이 equals를 재정의하고 Point.equals(ColorPoint)를 하는 경우 ColorPoint는 Point 타입이기 때문에 true를 반환하지만 반대의 경우인 ColorPoint.equals(Point)를 하는 경우 `if (!(o instanceof ColorPoint))` 해당 구문에서 o가 Point 타입이기 때문에 false를 반환하며 **대칭성**이 깨지게 된다.  

```java
// 코드 10-3 잘못된 코드 - 추이성 위배! (57쪽)
@Override 
public boolean equals(Object o) {
    if (!(o instanceof Point))
        return false;

    // o가 일반 Point면 색상을 무시하고 비교한다.
    if (!(o instanceof ColorPoint))
        return o.equals(this);

    // o가 ColorPoint면 색상까지 비교한다.
    return super.equals(o) && ((ColorPoint) o).color == color;
}

// 사용 예시
public static void main(String[] args) {
    // 두 번째 equals 메서드(코드 10-3)는 추이성을 위배한다. (57쪽)
    ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
    Point p2 = new Point(1, 2);
    ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
    System.out.printf("%s %s %s%n", p1.equals(p2), p2.equals(p3), p1.equals(p3)); // true true false
}
```

앞서 본 ColorPoint.equals(Point)인 경우 false의 결과를 반환하였다. 이를 방어하기 위해 위 equals 재정의 코드에서 `if (!(o instanceof Point))` 와 같이 Point 타입을 체크 수행하고 있는데, 해당 코드는 추이성이 깨질 수 있는 문제가 있다. 

우선 생각해볼 점은 상위 클래스인 Point에서 하위 타입에 대한 비교를 처리하는 경우이다.

```java
// 단순한 불변 2차원 정수 점(point) 클래스 (56쪽)
public class Point {
    ... 
    // 잘못된 코드 - 리스코프 치환 원칙 위배! (59쪽)
    @Override 
		public boolean equals(Object o) {
        if (o == null || o.getClass() != getClass())
            return false;
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
}
```

Point 클래스에서 `if (o == null || o.getClass() != getClass())` 를 통해  동일 타입에 대한 비교 처리를 고려해서 equals를 재정의 한 경우 **리스코프 치환 원칙**을 위배하는 문제가 있다.

다음 코드를 통해 위배되는 예시를 확인할 수 있다

```java
// Point의 평범한 하위 클래스 - 값 컴포넌트를 추가하지 않았다. (59쪽)
public class CounterPoint extends Point {
    private static final AtomicInteger counter =
            new AtomicInteger();

    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    }
    public static int numberCreated() { return counter.get(); }
}
```

- CounterPoint는 Point의 하위 클래스이고 equals를 재정의 하지 않아서 Point의 equals를 사용하게 된다.

```java
// CounterPoint를 Point로 사용하는 테스트 프로그램
public class CounterPointTest {
    // 단위 원 안의 모든 점을 포함하도록 unitCircle을 초기화한다. (58쪽)
    private static final Set<Point> unitCircle = Set.of(
            new Point( 1,  0), new Point( 0,  1),
            new Point(-1,  0), new Point( 0, -1));

    public static boolean onUnitCircle(Point p) {
        return unitCircle.contains(p);
    }

    public static void main(String[] args) {
        Point p1 = new Point(1,  0);
        Point p2 = new CounterPoint(1, 0);

        // true를 출력한다.
        System.out.println(onUnitCircle(p1));

        // true를 출력해야 하지만, Point의 equals가 getClass를 사용해 작성되었다면 그렇지 않다.
        System.out.println(onUnitCircle(p2));
    }
}
```

- 위 클래스에서 주요한점은 unitCircle 필드와 onUnitCircle 메소드인데 해당 메소드는 unitCircle 필드에 해당 파라미터가 포함됐는지 여부를 확인하는 메소드이다.
- onUnitCircle(new CounterPoint(1, 0)) 를 수행하는 경우 리스코프 치환 원칙에 따라서 true가 수행되어야하지만 Point 클래스에 다음과 같이 `if (o == null || o.getClass() != getClass())` equals를 재정의했기 때문에 false가 반환되는 것이다.
- 상속을 사용하는 경우 equals 사용하는 것에 주의가 필요하다.
- **ColorPoint와 CounterPoint 의 차이점은 추가된 필드의 여부이다.**
    - ColorPoint의 경우 필드가 추가됐다.
    - CounterPoint의 경우 추가된 필드가 없기 때문에 상위 클래스의 equals를 그대로 사용하면 되고 상위 클래스 입장에서도 하위 클래스를 전혀 고려할 필요가 없다.
    - 하위 클래스에서 필드가 추가된 경우 **대칭성과 추이성을 만족시키며 equals를 재정의 할 수 있는 방법이 존재하지 않는다.**

**대칭성이 깨진 java 코드 예시**

```java
public class EqualsInJava extends Object {

    public static void main(String[] args) throws MalformedURLException {
        long time = System.currentTimeMillis();
        Timestamp timestamp = new Timestamp(time);
        Date date = new Date(time);

        // 대칭성 위배! P60
        System.out.println(date.equals(timestamp));
        System.out.println(timestamp.equals(date));
    }
}
```

- 따라서 대칭성과 추이성을 만족하며 equals를 사용하고자 하는 경우 상속이 아닌 조합(composition)을 권장한다.

```java
// 코드 10-5 equals 규약을 지키면서 값 추가하기 (60쪽)
public class ColorPoint {
    private final Point point;
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        point = new Point(x, y);
        this.color = Objects.requireNonNull(color);
    }

    /**
     * 이 ColorPoint의 Point 뷰를 반환한다.
     */
    public Point asPoint() {
        return point;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
            return false;
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) && cp.color.equals(color);
    }

    @Override
    public int hashCode() {
        return 31 * point.hashCode() + color.hashCode();
    }
} 
```

```java
// CounterPoint를 Point로 사용하는 테스트 프로그램
public class CounterPointTest {
    ...
    public static void main(String[] args) {
        Point p1 = new Point(1,  0);
//        Point p2 = new CounterPoint(1, 0);
				// composition의 ColorPoint
        Point p2 = new ColorPoint(1, 0, Color.RED).asPoint();

        // true를 출력한다.
        System.out.println(onUnitCircle(p1));

        // true를 출력해야 하지만, Point의 equals가 getClass를 사용해 작성되었다면 그렇지 않다.
        System.out.println(onUnitCircle(p2));
    }
}
```

### 핵심 정리 4. equals 규약 - 일관성, null 아님

- `일관성: A.equals(B) == A.equals(B)`
    - `null-아님: A.equals(null) == false`

```java
public class EqualsInJava extends Object {

    public static void main(String[] args) throws MalformedURLException {
        ...
        // 일관성 위배 가능성 있음. P61
        URL google1 = new URL("https", "about.google", "/products/");
        URL google2 = new URL("https", "about.google", "/products/");
        System.out.println(google1.equals(google2));
    }
}
```

- 일관성을 지키기 위해 너무 복잡하게 구현하지 말라
    - 단순하게 특정 필드에 대해서 일관성을 지키도록 하는 것을 권장

### 핵심 정리 5. equals 구현 방법과 주의 사항

- `== 연산자를 사용해 자기 자신의 참조인지 확인한다.`
- `instanceof 연산자로 올바른 타입인지 확인한다.`
- `입력된 값을 올바른 타입으로 형변환 한다.`
- `입력 객체와 자기 자신의 대응되는 핵심 필드가 일치하는지 확인한다.`
    - 동기화 블록에 사용되는 필드는 비교하지 말라
    - Double, Float와 같이 부동 소수점에 영향을 받는 필드는 compare()로 비교한다.
    - null이 들어오는 필드는 Objects.equals()로 비교한다.

```java
// 단순한 불변 2차원 정수 점(point) 클래스 (56쪽)
public class Point {
    private final int x;
    private final int y;

		...
    @Override
    public boolean equals(Object o) {
        // 동일성 확인
        if (this == o) {
            return true;
        }
        // 타입 확인
        if (!(o instanceof Point)) {
            return false;
        }
        // 타입 케스팅
        Point p = (Point) o;
        // 핵심 필드 비교
        return p.x == x && p.y == y;
    }
		...
}
```

- `구글의 AutoValue 또는 Lombok을 사용한다.`

**AutoValue 예시**

```java
// build.gradle
// https://mvnrepository.com/artifact/com.google.auto.value/auto-value-annotations
implementation 'com.google.auto.value:auto-value-annotations:1.10.1'
implementation 'com.google.auto.value:auto-value:1.10.1'

/**
 * AutoValue 참고
 *
 * https://github.com/google/auto/blob/master/value/userguide/index.md
 */
@AutoValue
abstract class Point {
    static Point create(int x, int y) {
//        return new AutoValue_Point(x, y);
        return null;
    }

    abstract int x();
    abstract int y();
}

// 사용 예시
public class AutoValueTest {

    public static void main(String[] args) {
        Point point = Point.create(1, 2);
        System.out.println(point.equals(Point.create(1, 2)));
    }
}
```

- 라이브러리 빌드한 후에 코드 컴파일을 수행해야 결과로 AutoValue_Point 클래스가 생성되고 사용할 수 있다.
    - 이 라이브러리를 사용하는 것은 딱히 권장하지 않는다.
    - 컴파일 에러를 계속 봐야 하는 문제가 있음

**Lombok 예시**

```java
/**
 * https://projectlombok.org/features/EqualsAndHashCode
 * https://projectlombok.org/features/ToString
 */
@EqualsAndHashCode
@ToString
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

// 사용 예시
public class LombokTest {

    public static void main(String[] args) {
        Point point = new Point(1, 2);
        System.out.println(point.equals(new Point(1, 2)));
    }
}
```

- `IDE의 코드 생성 기능을 사용한다.`
    - 코드가 지저분해진다.
    - 필드가 추가되면 수정이 필요하다.
- `과제) 자바의 Record를 공부하세요.`
    - java 14, 15 부터 추가된 기능

```java
public record Point(int x, int y) {
		public String hello() {
				return "hello";
		}
}

// 사용 예시
public class PointTest {

    public static void main(String[] args) {
        Point p1 = new Point(1, 0);
        Point p2 = new Point(1, 0);
        System.out.println(p1.equals(p2));
        System.out.println(p1);

        System.out.println(p1.x());
        System.out.println(p1.y());
    }
}
```

- java beans 규약을 따르지는 않음 setter 구현 불가, getter는 필드이름() 형태로 호출가능
- record 클래스는 불변하다.
- equals, hashcode, toString 를 컴파일 시점에 자동으로 생성
- `equals를 재정의 할 때 hashCode도 반드시 재정의하자. (아이템 11)`
- `너무 복잡하게 해결하지 말자.`
- `Object가 아닌 타입의 매개변수를 받는 equals 메서드는 선언하지 말자.`
    - Object가 아닌 타입의 매개변수를 받는 메소드를 만드는 것은 오버로딩한 것이고 다른 메소드인 것이다.

## 완벽 공략

### 완벽 공략 24. Value 기반의 클래스

- `p53, 값 클래스`

`클래스처럼 생겼지만 int 처럼 동작하는 클래스`

- `식별자가 없고 불변이다.`
- `식별자가 아니라 인스턴스가 가지고 있는 상태를 기반으로 equals, hashCode, toString을 구현한다.`
- `== 오퍼레이션이 아니라 equals를 사용해서 동등성을 비교한다.`
- `동일한(equals) 객체는 상호교환 가능한다.`

- [`https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html`](https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html)
- [`https://cr.openjdk.java.net/~jrose/values/values-0.html`](https://cr.openjdk.java.net/~jrose/values/values-0.html)
- DDD의 Value Object와 동일한 개념
- record 클래스 참고

### 완벽 공략 25. StackOverflowError

- `p58, StackOverflowError`

`로컬 변수와 객체가 저장되는 공간의 이름은?`

- `스택(stack)과 힙(heap)`
    - 스택은 스레드 마다 사용할 수 있는 메모리 공간을 말한다.
    - 힙은 객체가 존재하는 공간 GC 정리 대상
- `메소드 호출시, 스택에 스택 프레임이 쌓인다.`
    - `스택 프레임에 들어있는 정보: 메소드에 전달하는 매개변수, 메소드 실행 끝내고 돌아갈 곳, 힙에 들어있는 객채에 대한 레퍼런스…`
    - `그런데 더이상 스택 프레임을 쌓을 수 없다면? StackOverflowError!`
- `스택의 사이즈를 조정하고 싶다면? -Xss1M`
    - [`https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/jrdocs/refman/optionX.html`](https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/jrdocs/refman/optionX.html)

**StackOverflowError 발생 예시**

```java
public class SmellPoint extends Point {

    private String smell;

    public SmellPoint(int x, int y, String smell) {
        super(x, y);
        this.smell = smell;
    }

    @Override public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;

        // o가 일반 Point면 색상을 무시하고 비교한다.
        if (!(o instanceof SmellPoint))
            return o.equals(this);

        // o가 ColorPoint면 색상까지 비교한다.
        return super.equals(o) && ((SmellPoint) o).smell.equals(smell);
    }
}

// 사용 예시
public class SmellPointTest {

    /**
     * TODO -Xss10M
     * @param args
     */
    public static void main(String[] args) {
        SmellPoint p1 = new SmellPoint(1, 0, "sweat");
        ColorPoint p2 = new ColorPoint(1, 0, Color.RED);
        p1.equals(p2);
    }
}
```

- equals의 `if (!(o instanceof SmellPoint)) return o.equals(this);` 해당 구문에서 ColorPoint와 SmellPoint 간의 무한정 호출로 인해 에러가 발생하게 된다.

### 완벽 공략 26. 리스코프 치환 원칙

- `p59, 리스코프 치환 원칙`
- `p59, 상속 대신 컴포지션을 사용하라. (아이템 18)`

`객체 지향 5대 원칙 SOLID 중에 하나.`

- `1994년, 바바라 리스코프의 논문, “A Behavioral Notion of Subtyping”에서 기원한 객체 지향 원칙.`
- `‘하위 클래스의 객체’가 ‘상위 클래스 객체’를 대체하더라도 소프트웨어의 기능을 깨트리지 않아야 한다. (semantic over syntacic, 구문 보다는 의미!)`