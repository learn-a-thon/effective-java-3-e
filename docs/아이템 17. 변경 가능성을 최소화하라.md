# 아이템 17. 변경 가능성을 최소화하라

## 핵심 정리

### 핵심 정리 1: 불변 클래스

- `불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.`
    - 인스턴스 상태가 한번 설정되면 변경되지 않는 클래스
- `불변 클래스를 만드는 다섯 가지 규칙`
    - `객체의 상태를 변경하는 메서드를 제공하지 않는다.`
        - setter를 제공하지 않는다.
    - `클래스를 확장할 수 없도록 한다.`
        - public final class 와 같이 클래스에 final로 지정하면 상속이 불가하게 된다.
    - `모든 필드를 final로 선언한다. ([JLS 17.5](https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-17.5))`
    - `모든 필드를 private으로 선언한다. (아이템 15, 16)`
    - `자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.`
        - 객체 안에 객체를 외부로 노출하지 말라는 의미

**불변 클래스 예시**

```java
public final class PhoneNumber {

    private final short areaCode, prefix, lineNum;

    public PhoneNumber(short areaCode, short prefix, short lineNum) {
        this.areaCode = areaCode;
        this.prefix = prefix;
        this.lineNum = lineNum;
    }

    public short getAreaCode() {
        return areaCode;
    }

    public short getPrefix() {
        return prefix;
    }

    public short getLineNum() {
        return lineNum;
    }
}
```

**객체 내부의 가변 컴포넌트 접근 예시**

```java
public final class Person {

    private final Address address;

    public Person(Address address) {
        this.address = address;
    }

		// 방어적으로 복사본을 전달하는 것이 좋다.
    public Address getAddress() {
        Address copyOfAddress = new Address();
        copyOfAddress.setStreet(address.getStreet());
        copyOfAddress.setZipCode(address.getZipCode());
        copyOfAddress.setCity(address.getCity());
        return copyOfAddress;
    }

    public static void main(String[] args) {
        Address seattle = new Address();
        seattle.setCity("Seattle");

        Person person = new Person(seattle);

        Address redmond = person.getAddress();
        redmond.setCity("Redmond");

        System.out.println(person.address.getCity());
    }
}
```

- 내부 객체의 변경을 최대한 불가하게 하는 것이 핵심

### 핵심 정리 2: 불변 클래스의 장점과 단점

- `함수형 프로그래밍에 적합하다. (피연산자에 함수를 적용한 결과를 반환하지만 피연산자가 바뀌지는 않는다.)`

```java
// 코드 17-1 불변 복소수 클래스 (106-107쪽)
public final class Complex {
    private final double re;
    private final double im;

    public static final Complex ZERO = new Complex(0, 0);
    public static final Complex ONE = new Complex(1, 0);
    public static final Complex I = new Complex(0, 1);

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart() {
        return re;
    }

    public double imaginaryPart() {
        return im;
    }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    // 코드 17-2 정적 팩터리(private 생성자와 함께 사용해야 한다.) (110-111쪽)
    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im,
                re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
                (im * c.re - re * c.im) / tmp);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Complex))
            return false;
        Complex c = (Complex) o;

        // == 대신 compare를 사용하는 이유는 63쪽을 확인하라.
        return Double.compare(c.re, re) == 0
                && Double.compare(c.im, im) == 0;
    }

    @Override
    public int hashCode() {
        return 31 * Double.hashCode(re) + Double.hashCode(im);
    }

    @Override
    public String toString() {
        return "(" + re + " + " + im + "i)";
    }
}
```

- `불변 객체는 단순하다.`
- `불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.`
    - 변경이 불가능 하기 때문
- `불변 객체는 안심하고 공유할 수 있다. (상수, public static final)`
- `불변 객체 끼리는 내부 데이터를 공유할 수 있다.`
    - 불변 객체 안에 불변 객체여야 한다.(오염이 안되게 해야한다는 것)

```java
public class BigIntExample {

    public static void main(String[] args) {
        BigInteger ten = BigInteger.TEN;
        BigInteger minusTen = ten.negate();

        final Set<Point> points = new HashSet<>();
        Point firstPoint = new Point(1, 2);
        points.add(firstPoint);

        // 불변 클래스이기 때문에 변경 불가능
        // firstPoint.x = 10;
    }
    
    static class Point {
        public final int x;
        public final int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```

- `객체를 만들 때 불변 객체로 구성하면 이점이 많다.`
- `실패 원자성을 제공한다. (아이템 76, p407)`

```java
public final class Complex {
    private final double re;		
		
		public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
                (im * c.re - re * c.im) / tmp);
    }
		...
}
```

- 연산을 수행하는 과정에서 에러가 발생할 수 있다는 것이다.
    - 불변 객체 뿐 아니라 가변 객체에서도 발생할 수 있다.
    - 불변 객체의 경우 값이 변경되는 것은 아니기 때문에 유의미 하다고 볼 수 있다.
- `단점) 값이 다르다면 반드시 별도의 객체로 만들어야 한다.`
    - `"다단계 연산"을 제공하거나, "가변 동반 클래스"를 제공하여 대처할 수 있다.`
    - “다단계 연산”은 plusAndMinus() 와 같은 메소드를 제공하는 것을 말한다.
        - Complex의 사칙연산을 수행하는 경우 매번 새로운 인스턴스가 생성될 수 있는데 무분별하게 인스턴스가 생성되는 것을 막기 위한 대안으로 고려

**“가변 동반 클래스”는 가변 클래스 예시**

```java
public class StringExample {

    public static void main(String[] args) {
        String name = "hello";

				// 가변 동반 클래스
        StringBuilder nameBuilder = new StringBuilder(name);
        nameBuilder.append("world");
    }
}
```

- 값의 변경이 많이 발생하는 경우 고려할 수 있다

### 핵심 정리 3: 불변 클래스 만들 때 고려할 것

- `상속을 막을 수 있는 또 다른 방법`
    - `private 또는 package-private 생성자 + 정적 팩터리`
    - `확장이 가능하다. 다수의 package-private 구현 클래스를 만들 수 있다.`
    - `정적 팩터리를 통해 여러 구현 클래스중 하나를 활용할 수 있는 유연성을 제공하고 객체 캐싱 기능으로 성능을 향상 시킬 수도 있다.`

```java
// 코드 17-1 불변 복소수 클래스 (106-107쪽)
public class Complex { // effectivly final(사실상 final 이라는 의미)
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

		...

    // 코드 17-2 정적 팩터리(private 생성자와 함께 사용해야 한다.) (110-111쪽)
    public static Complex valueOf(double re, double im) {
        return new MyComplex(re, im);
    }

		...

    private static class MyComplex extends Complex {

        private MyComplex(double re, double im) {
            super(re, im);
        }
    }
}
```

- 외부에서는 상속이 가능해 보이지만 effectivly final인 클래스이다.
- `재정의가 가능한 클래스는 방어적인 복사를 사용해야 한다.`

**방어적인 복사 예시**

```java
public class BigIntegerUtils {

    public static BigInteger safeInstance(BigInteger val) {
        return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());
    }
}
```

- `모든 "외부에 공개하는" 필드가 final이어야 한다.`
    - `계산 비용이 큰 값은 해당 값이 필요로 할 때 (나중에) 계산하여 final이 아닌 필드에 캐시해서 쓸 수도 있다.`

```java
// equals를 재정의하면 hashCode로 재정의해야 함을 보여준다. (70-71쪽)
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;

    public PhoneNumber(int areaCode, int prefix, int lineNum) {
        this.areaCode = rangeCheck(areaCode, 999, "area code");
        this.prefix = rangeCheck(prefix, 999, "prefix");
        this.lineNum = rangeCheck(lineNum, 9999, "line num");
    }

    ...

    // 해시코드를 지연 초기화하는 hashCode 메서드 - 스레드 안정성까지 고려해야 한다. (71쪽)
    private volatile int hashCode; // 자동으로 0으로 초기화된다.

    @Override
    public int hashCode() {
        if (this.hashCode != 0) {
            return hashCode;
        }

        synchronized (this) {
            int result = hashCode;
            if (result == 0) {
                result = Short.hashCode(areaCode);
                result = 31 * result + Short.hashCode(prefix);
                result = 31 * result + Short.hashCode(lineNum);
                this.hashCode = result;
            }
            return result;
        }
    }

    public static void main(String[] args) {
        Map<PhoneNumber, String> m = new HashMap<>();
        m.put(new PhoneNumber(707, 867, 5309), "제니");
        System.out.println(m.get(new PhoneNumber(707, 867, 5309)));
    }
}
```

- hashCode()가 호출돼서 계산될때 hashCode 필드에 값이 저장된다.
    - 계산할 때 마다 같은 값이 나오는 경우(멱등한 경우)에만 사용(??)
    - 이후에 hashCode 값을 사용할때 앞서 계산된 값을 사용하게 된다.

## 완벽 공략

- `p105, 새로 생성된 불변 인스턴스를 동기화 없이 다른 스레드로 건네도 문제 없이 동작 (JLS 17.5)`
- `p106, readObject 메서드 (아이템 88)에서 방어적 복사를 수행하라.`
    - 직렬화와 관련됨
- `p112, 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있다면… (아이템 88)`
- `p113, java.util.concurrnet 패키지의 CountDownLatch 클래스`

### 완벽 공략 32. final과 자바 메모리 모델(JMM)

`final을 사용하면 안전하게 초기화 할 수 있다.`

어떻게 안전하게 초기화하는가? final을 안쓰면 안전하지 않은가?

- `JMM과 final을 완벽히 이해하려면 [JLS 17.4](https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-17.4)와 [JLS 17.5](https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-17.5)를 참고하세요.`
- `JMM:`
    - `자바 메모리 모델은 JVM의 메모리 구조가 아닙니다.`
    - `적법한 (legal) 프로그램을 실행 규칙.`
    - `메모리 모델이 허용하는 범위내에서 프로그램을 어떻게 실행하든 구현체(JVM)의 자유다. (이 과정에서 실행 순서가 바뀔 수도 있다.)`
- `어떤 인스턴스의 final 변수를 초기화 하기 전까지 해당 인스턴스를 참조하는 모든 쓰레스는 기다려야 한다. (freeze)`

```java
public class Foo {
    private final int x;
    private final int y;

    public Foo() {
        this.x = 1;
        this.y = 2;
    }

    public static void main(String[] args) {
				// 필드에 final 키워드가 없다면 아래 실행 순서가 다를 수 있다.
        // Object obj = new Foo()
        // foo = obj
        // obj.x = 1
        // obj.y = 2

        Foo foo = new Foo();
    }
}
```

- 자바 실행 스펙에 따르자면 JMM 구조 상 다음과 같이 인스턴스를 생성할 수 있다.(즉, 실행 순서가 달라 질 수 있다는 의미)
    - Object w  = new Foo(); → obj.x = 1; obj.y = 2; → foo = obj; 순으로 동작할 수 있고
    - Object w  = new Foo(); →  foo = obj; → obj.x = 1; obj.y = 2; 순으로 동작할 수 있다
        - 이 경우 final 키워드가 없는 경우 obj.x, obj.y 에 값이 할당되지 않을 수 있다는 것이다.
        - 반대로 final 키워드가 존재하는 경우 아래와 같이 JMM 스펙에선 final 필드에 대해서 값이 할당되는 것을 보장하게 된다고 한다.(안전하게 초기화)
- 멀티 스레드 환경에서 안전하게 초기화하려면 final 키워드를 선언해야 한다.

**Final Fields in The Java Memory Model**

```java
class FinalFieldExample { 
    final int x;
    int y; 
    static FinalFieldExample f;

    public FinalFieldExample() {
        x = 3; 
        y = 4; 
    } 

    static void writer() {
        f = new FinalFieldExample();
    } 

    static void reader() {
        if (f != null) {
            int i = f.x;  // guaranteed to see 3  
            int j = f.y;  // could see 0
        } 
    } 
}
```

### 완벽 공략 33. java.util.concurrnet 패키지

`병행(concurrency) 프로그래밍에 유용하게 사용할 수 있는 유틸리티 묶음`

- `병행(Concurrency)과 병렬(Parallelism)의 차이`

![item17-1](images/item17-1.png)

- `병행은 여러 작업을 번갈아 가며 실행해 마치 동시에 여러 작업을 동시에 처리하듯 보이지만, 실제로는 한번에 오직 한 작업만 실행한다. CPU가 한개여도 가능하다.`
- `병렬은 여러 작업을 동시에 처리한다. CPU가 여러개 있어야 가능하다.`
- `자바의 concurrent 패키지는 병행 애플리케이션에 유용한 다양한 툴을 제공한다.`
- `BlockingQueue, Callable, ConcurrrentMap, Executor, ExecutorService, Future, …`

### 완벽 공략 33. CountDownLatch

`다른 여러 스레드로 실행하는 여러 오퍼레이션이 마칠 때까지 기다릴 때 사용할 수 있는 유틸리티`

- `초기화 할 때 숫자를 입력하고, await() 메서드를 사용해서 숫자가 0이 될때까지 기다린다.`
- `숫자를 셀 때는 countDown() 메서드를 사용한다.`
- `재사용할 수 있는 인스턴스가 아니다. 숫자를 리셋해서 재사용하려면 CyclicBarrier를 사용해야 한다.`
- `시작 또는 종료 신호로 사용할 수 있다.`

```java
public class ConcurrentExample {
    public static void main(String[] args) throws InterruptedException {
        int N = 10;
        CountDownLatch startSignal = new CountDownLatch(1);
        CountDownLatch doneSignal = new CountDownLatch(N);

        for (int i = 0; i < N; ++i) // create and start threads
            new Thread(new Worker(startSignal, doneSignal)).start();

        ready();            // don't let run yet
        startSignal.countDown();      // let all threads proceed
        doneSignal.await();           // wait for all to finish
        done();
    }

    private static void ready() {
        System.out.println("준비~~~");
    }

    private static void done() {
        System.out.println("끝!");
    }

    private static class Worker implements Runnable {

        private final CountDownLatch startSignal;
        private final CountDownLatch doneSignal;

        public Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
            this.startSignal = startSignal;
            this.doneSignal = doneSignal;
        }

        public void run() {
            try {
                startSignal.await();
                doWork();
                doneSignal.countDown();
            } catch (InterruptedException ex) {} // return;
        }

        void doWork() {
            System.out.println("working thread: " + Thread.currentThread().getName());
        }
    }
}
```

- CountDownLatch는 재사용 가능한 클래스가 아니다.

# References

- [https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-17.5](https://docs.oracle.com/javase/specs/jls/se14/html/jls-17.html#jls-17.5)