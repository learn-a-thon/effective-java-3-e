# 아이템 7. 다 쓴 객체 참조를 해제하라

## 핵심 정리

- `어떤 객체에 대한 레퍼런스가 남아있다면 해당 객체는 가비지 컬렉션의 대상이 되
지 않는다.`
- `자기 메모리를 직접 관리하는 클래스라면 메모리 누수에 주의해야 한다.`
    - `예) 스택, 캐시, 리스너 또는 콜백`
- `참조 객체를 null 처리하는 일은 예외적인 경우이며 가장 좋은 방법은 유효 범위
밖으로 밀어내는 것이다.`

**메모리 해제 방법1**

- 명시적으로 자원을 해제한다.

```java
public class Stack {
		...
		public Object pop() {
		    ...
		    elements[size] = null; // 다 쓴 참조 해제
		    return result;
		}
}
```

**메모리 해제 방법2**

- **WeekHashMap, WeekReference**
    - **WeekHashMap**는 **WeekReference**를 키로 갖는 Map
        - 키가 더이상 참조(strong)되지 않으면(week 하다면) 해당 키로 가지고 있는 value를 제거해준다.
    - **WeekReference**의 Reference에는 strong, soft, week, phantom가 있다.

```java
// weekHashMap
public class PostRepository {
    private Map<CacheKey, Post> cache;

    public PostRepository() {
        this.cache = new WeakHashMap<>();
    }
		...
}

// list collection
public class ChatRoom {
    // 올바른 WeakReference 사용 방법이 아니다
    private List<WeakReference<User>> users;

    public ChatRoom() {
        this.users = new ArrayList<>();
    }
}
```

```java
@Test
void cache() throws InterruptedException {
    PostRepository postRepository = new PostRepository();
    CacheKey key1 = new CacheKey(1);
    postRepository.getPostById(key1);

    assertFalse(postRepository.getCache().isEmpty());

    key1 = null;
    // TODO run gc
    System.out.println("run gc");
    System.gc();
    System.out.println("wait");
    Thread.sleep(3000L);

    assertTrue(postRepository.getCache().isEmpty());
}
```

- WeekHashMap의 경우 Key 값으로 설정된 객체의 생성 영역에 따라서 WeekReference가 될 수 있고 이는 GC 시점에 해당 객체의 자원을 해제한다.
    - 만약 getPostById() 내부에서 CacheKey를 생성하는 경우 외부 코드에서는 CacheKey가 WeekReference이기 때문에 자원이 해제 된다.

**메모리 해제 방법3**

- 가장 오래된 리소스를 직접 제거해주는 방법
- LRU(Lastest Recently Used) Cache 참고

**메모리 해제 방법4**

- background thread 를 사용하여 주기적으로 정리하는 방법

```java
@Test
void backgroundThread() throws InterruptedException {
    ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
    PostRepository postRepository = new PostRepository();
    CacheKey key1 = new CacheKey(1);
    postRepository.getPostById(key1);

    Runnable removeOldCache = () -> {
        System.out.println("running removeOldCache task");
        Map<CacheKey, Post> cache = postRepository.getCache();
        Set<CacheKey> cacheKeys = cache.keySet();
        Optional<CacheKey> key = cacheKeys.stream().min(Comparator.comparing(CacheKey::getCreated));
        key.ifPresent((k) -> {
            System.out.println("removing " + k);
            cache.remove(k);
        });
    };

    System.out.println("The time is : " + new Date());

    executor.scheduleAtFixedRate(removeOldCache,
            1, 3, TimeUnit.SECONDS);

    Thread.sleep(20000L);

    executor.shutdown();
}
```

## 완벽 공략

### 완벽 공략 19. NullPointerException

- `p37, NullPointerException`

`Java 8 Optional을 활용해서 NPE를 최대한 피하자.`

- `NullPointerException을 만나는 이유`
    - `메소드에서 null을 리턴하기 때문에 && null 체크를 하지 않았기 때문에`

```java
// Channel.class
public class Channel {
    private int numOfSubscribers;

    public MemberShip defaultMemberShip() {
        if (this.numOfSubscribers < 2000) {
            return null;
        } else {
            return Optional.of(new MemberShip());
        }
    }
}

// MemberShip.class
public class MemberShip {
    public String hello() {
        return "hello";
    }
}

// npe 발생 예시
class ChannelTest {
    @Test
    void npe() {
        Channel channel = new Channel();
        MemberShip memberShip = channel.defaultMemberShip();
				MemberShip.hello(); // npe 발생
    }
}
```

- `메소드에서 적절한 값을 리턴할 수 없는 경우에 선택할 수 있는 대안`
    - `예외를 던진다.`
    - `null을 리턴한다.`
    - `Optional을 리턴한다.`

```java
public class Channel {
    private int numOfSubscribers;

		// npe 방어 1) exception 발생
    public MemberShip defaultMemberShip() {
        if (this.numOfSubscribers < 2000) {
            throws new Exception();
        } else {
            return new MemberShip();
        }
    }

		// npe 방어 2) optional
    public Optional<MemberShip> defaultMemberShip() {
        if (this.numOfSubscribers < 2000) {
            return Optional.empty();
        } else {
            return Optional.of(new MemberShip());
        }
    }
}
```

Optional 활용 예시

```java
@Test
void npe() {
    Channel channel = new Channel();
    Optional<MemberShip> memberShipOptional = channel.defaultMemberShip();
    memberShipOptional.ifPresent(MemberShip::hello);
}
```

- `Optional 사용시 주의 할 점`
    - `리턴값으로만 쓰기를 권장한다. (메소드 매개변수 타입, 맵의 키 타입, 인스턴스 필드 타입으로 쓰지 말자.) 왜?`
    - `Optional을 리턴하는 메소드에서 null을 리턴하지 말자.`
    - `프리미티브 타입용 Optional을 따로 있다. OptionalInt, OptionalLong, ...`
    - `Collection, Map, Stream Array, Optional은 Opiontal로 감싸지 말 것.`

```java
// Optional을 메소드 파라미터로 사용하지 말라
public Optional<MemberShip> defaultMemberShip(Optional<MemberShip> memberShip) {
}

// Optional을 리턴하는 메소드에서 null을 반환하지 말라
public Optional<MemberShip> defaultMemberShip() {
		...
		return null;
}
```

- `아이템 55, Optional 반환은 신중히 하라.`

### 완벽 공략 20. WeakHashMap

- `p38, WeakHashMap`
    - `p38, 약한 참조 (weak reference)`

`더이상 사용하지 않는 객체를 GC할 때 자동으로 삭제해주는 Map`

> 기존 Map, Set, Array와 같은 Collection 내부의 엔트리(객체 인스턴스)들은 GC가 발생해도 바로 지워지지 않는다.
> 
- `Key가 더이상 강하게 레퍼런스되는 곳이 없다면 해당 엔트리를 제거한다.`

**WeakHashMap 사용 주의 사항**

Map의 key 값이 커스텀한 객체 레퍼런스가 아니라 상수풀이 존재하는 레퍼 타입(Integer, String)를 key로 사용하는 경우 GC가 발생해도 지워지지 않을 가능성이 있다.(Integer, String은 JVM 내부에 일부 값이 캐싱 돼있기 때문)

```java
@Test
void cache() throws InterruptedException {
    PostRepository postRepository = new PostRepository();
    //CacheKey key1 = new CacheKey(1);
		Integer key1 = 1; // 사용 주의!!
    postRepository.getPostById(key1);

    assertFalse(postRepository.getCache().isEmpty());

    key1 = null;
    // TODO run gc
    System.out.println("run gc");
    System.gc();
    System.out.println("wait");
    Thread.sleep(3000L);

    assertTrue(postRepository.getCache().isEmpty());
}
```

- `레퍼런스 종류`
    - `Strong, Soft, Weak, Phantom`

`Strong`

```java
// strong reference
new ArrayList<>();
```

`Soft`

```java
public static void main(String[] args) throws InterruptedException {
    Object strong = new Object();
    SoftReference<Object> soft = new SoftReference<>(strong);
    strong = null;

    System.gc();
    Thread.sleep(3000L);

    // TODO 거의 안 없어집니다.
    //  왜냐면 메모리가 충분해서.. 굳이 제거할 필요가 없으니까요.
    System.out.println(soft.get());
} 
```

- GC가 메모리가 필요한 상황에 해당 객체(soft reference)는 정리 대상이 된다.

`Week`

```java
public static void main(String[] args) throws InterruptedException {
    Object strong = new Object();
    WeakReference<Object> weak = new WeakReference<>(strong);
    strong = null;

    System.gc();
    Thread.sleep(3000L);

    // TODO 거의 없어집니다.
    //  왜냐면 약하니까(?)...
    System.out.println(weak.get());
}
```

- GC가 발생하면 바로 정리 대상이 된다.

`Phantom`

```java
public static void main(String[] args) throws InterruptedException {
    BigObject strong = new BigObject();
    ReferenceQueue<BigObject> rq = new ReferenceQueue<>();

//        BigObjectReference<BigObject> phantom = new BigObjectReference<>(strong, rq);
    
		// PhantomReference의 생성자는 ReferenceQueue를 넘겨줘야한다.
    // GC가 발생하면 본래 가지고 있던 레퍼런스는 정리하고(null 이기 때문)
    // phantom 레퍼런스는 ReferenceQueue에 넣어준다.
		PhantomReference<BigObject> phantom = new PhantomReference<>(strong, rq);
    
    strong = null;

    System.gc();
    Thread.sleep(3000L);

    // TODO 팬텀은 유령이니까..
    //  죽었지만.. 사라지진 않고 큐에 들어갑니다.
    System.out.println(phantom.isEnqueued());

    Reference<? extends BigObject> reference = rq.poll();
    BigObjectReference bigObjectCleaner = (BigObjectReference) reference;
    bigObjectCleaner.cleanUp();

		// clear를 직접 해줘야 phantom reference가 사라진다.
    reference.clear();
}
```

- strong 인스턴스 대신 phantom이 남아있는다고 생각하면된다.
- **사용 목적**
    - 자원 정리
        - finalize 보다 조금 더 나은 방법(최악의 방법)
        - try-resource(최선의 방법)
    - 어느 시점에 메모리가 해제 되는지 시점을 알 수 있다.
- GC가 발생하면 strong 레퍼런스는 정리되고 phantom 레퍼런스는 ReferenceQueue에 들어간다.
- `맵의 엔트리를 맵의 Value가 아니라 Key에 의존해야 하는 경우에 사용할 수 있다.`
- `캐시를 구현하는데 사용할 수 있지만, 캐시를 직접 구현하는 것은 권장하지 않는다.`

`weekReference`

WeekHashMap에서 key 값이 사용되지 않는 경우 GC에 의해 key, value가 자원 해제되는 기능은 아래와 같이 WeakReference를 엘리먼트로 가지는 List에는 적용되지 않는다.

만약 WeakReference 자체를 메모리 정리하고 싶다면 WeakReference를 상속받는 커스텀한 리스트 객체를 사용해야한다.

```java
public class ChatRoom {
    // 올바른 WeakReference 사용 방법이 아니다
    private List<WeakReference<User>> users;

}
```

```java
class ChatRoomTest {

    @Test
    void charRoom() throws InterruptedException {
        ChatRoom chatRoom = new ChatRoom();
        User user1 = new User();
        User user2 = new User();

        chatRoom.addUser(user1);
        chatRoom.addUser(user2);

        chatRoom.sendMessage("hello");

        user1 = null;

        System.gc();

        Thread.sleep(5000L);

        List<WeakReference<User>> users = chatRoom.getUsers();
        assertTrue(users.size() == 1);
    }
}
```

### 완벽 공략 21. ScheduledThreadPoolExecutor

- `p39, 백그라운드 쓰레드`
    - `p39, ScheduledThreadPoolExecutor`

`Thread와 Runnable을 학습했다면 그 다음은 Executor.`

- `Thread, Runnable, ExecutorService`

**Thread, Runnable 예시**

```java
public class ThreadRunnableExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread thread = new Thread(new Task());

        thread.start();

        System.out.println(Thread.currentThread() + " hello");
    }

    static class Task implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(2000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread() + " world");
        }
    }
}
```

- thread를 생성하는 것은 시스템 리소스에 부하를 주는 것이다.

```java
public class ThreadRunnableExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        for (int i = 0; i < 100; i++) {
            Thread thread = new Thread(new Task());
            thread.start();
        }
        System.out.println(Thread.currentThread() + " hello");
    }
		...
}
```

Q. 특정 로직 100번 수행하는데 100개의 스레드를 생성하여 수행하고 있다. 만약 해당 로직이 스레드를 100개까지 필요로 하지 않는다면?? 

thread pool을 활용한다. thread pool을 활용한다는 의미는 pool에 10개의 thread가 존재한다고 할 때, 해당 thread들이 로직 100번을 수행하게 되는 것이다.(불필요한 자원을 낭비하지 않는 방법)

```java
public class ThreadRunnableExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 100; i++) {
            service.submit(new Task());
        }
        System.out.println(Thread.currentThread() + " hello");
    }
		...
}
```

- `쓰레드풀의 개수를 정할 때 주의할 것`
    - `CPU, I/O`
    - CPU에 주요한 작업인지, IO에 주요한 작업인지에 따라 스레드 풀 개수를 설정한다.
    - IO에 집중적인 작업의 경우 많은 스레드를 필요로한다.

**cpu 개수 만큼 스레드 풀 생성하기**

```java
public class ThreadRunnableExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // cpu 개수
        int numberOfCpu = Runtime.getRuntime().availableProcessors();
        System.out.println("numberOfCpu = " + numberOfCpu);

        ExecutorService service = Executors.newFixedThreadPool(numberOfCpu);
        for (int i = 0; i < 100; i++) {
            service.submit(new Task());
        }
        System.out.println(Thread.currentThread() + " hello");
    }
		...
}
```

- `쓰레드툴의 종류`
    - `Single, Fixed, Cached, Scheduled`

`Single`

```java
ExecutorService service = Executors.newSingleThreadExecutor();
```

- 싱글 스레드로 동작
- 스레드를 만들고 없애는 컨텍스트 스위칭 작업에 소요되는 시간이 많아 질 수 있다.

`Fixed`

```java
ExecutorService service = Executors.newFixedThreadPool(10);
```

- 내부적으로 blocking queue를 사용한다.
    - 작업을 큐에 넣는다.
- concurrent 하게 작업할 수 있다.
    - List와 같은 Collection은 concurrency하지 않음

`Cached`

```java
ExecutorService service = Executors.newCachedThreadPool();
```

- 자기가 필요한 만큼 스레드를 생성한다. 놀고 있는 스레드를 재사용하기도 함
- 오래 놀고있는 스레드는 60초가 지나면 없애준다.
- 작업을 위한 큐가 하나이다.
- 스레드가 무한정 늘어날 수 있다.

`Scheduled`

```java
ExecutorService service = Executors.newScheduledThreadPool(10);
```

- 작업을 몇 초 뒤 or 주기적으로 동작하게 한다.
- `Runnable, Callable, Future`

`Runnable`

```java
static class Task implements Runnable {
    @Override
    public void run() {
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread() + " world");
    }
}
```

`Callable`

```java
public class ExecutorsExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(10);

        Future<String> submit = service.submit(new Task()); // non blocking call

        System.out.println(Thread.currentThread() + " hello"); // non blocking call

        System.out.println(submit.get()); // blocking call: 2초 대기

        service.shutdown();
    }

    static class Task implements Callable<String> {
        @Override
        public String call() throws Exception {
            Thread.sleep(2000L);
            return Thread.currentThread() + " world";
        }
    }
}
```

- 스레드 작업에 대한 결과를 반환받을 수 있다.
- `CompletableFuture, ForkJoinPool`

## 심화 학습 키워드

- ExecutorService
- blocking call, non blocking call
- CompletableFuture
- ForkJoinPool