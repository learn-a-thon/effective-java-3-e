# 아이템 39. 명명 패턴보다 애너테이션을 사용하라

과거 프레임워크 등의 프로그램은 명명 패턴을 적용해왔다. 예컨데 테스트 프레임워크인 JUnit 3의 경우 테스트 메서드 이름을 test로 시작하게끔 했다. 그러나 명명 패턴은 여러 단점을 가진다.

- 오타가 나면 안 된다.
- 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다.
    - 만약 개발자가 TestMemberSave라는 클래스를 정의하고 클래스에 정의된 메서드들을 테스트 하길 기대한다고 하자. 그러나, JUnit은 클래스 이름에 관심이 없기 때문에 개발자가 의도하는 테스트를 수행할 수 없다.
- 프로그램 요소를 매개변수로 전달할 방법이 없다.
    - 특정 예외를 던져야 성공하는 테스트의 경우, 예외 타입을 테스트 메서드에 매개변수로 전달해야하는 상황이다. 메서드 이름에 예외 이름을 지정하는 방법도 있지만 깨지기 쉽고 컴파일러가 예외인지 알 수 없는 문제가있다.

애너테이션[JLS, 9.7]은 이 모든 문제를 해결해준다.

```java
/**
 * 테스트 메서드임을 선언하는 애너테이션이다.
 * 매개변수 없는 정적 메서드 전용이다.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}
```

- @Retention, @Target과 같은 애너테이션에 다는 애너테이션은 메타애너테이션(meta-annotation)이라 한다.
    - @Retention은 런타임에도 유지되어야 한다는 표시
    - @Target은 반드시 메서드 선언에만 사용돼야 한다는 표기
- javax.annotation.processing API 문서 참고

```java
// 코드 39-2 마커 애너테이션을 사용한 프로그램 예 (239쪽)
public class Sample {
    @Test
    public static void m1() {
    }        // 성공해야 한다.

    public static void m2() {
    }

    @Test
    public static void m3() {    // 실패해야 한다.
        throw new RuntimeException("실패");
    }

    public static void m4() {
    }  // 테스트가 아니다.

    @Test
    public void m5() {
    }   // 잘못 사용한 예: 정적 메서드가 아니다.

    public static void m6() {
    }

    @Test
    public static void m7() {    // 실패해야 한다.
        throw new RuntimeException("실패");
    }

    public static void m8() {
    }
} 
```

- @Test와 같이 “아무 매개변수 없이 단순히 대상에 마킹(marking)한다”는 뜻에서 마커(marker) 애너테이션이라 한다.
- @Test 애너테이션이 클래스에 직접적인 영향을 주지는 않는다.
    - 추가적인 정보를 제공할 뿐이다.

```java
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

// 코드 39-3 마커 애너테이션을 처리하는 프로그램 (239-240쪽)
public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class<?> testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(Test.class)) {
                tests++;
                try {
                    m.invoke(null);
                    passed++;
                } catch (InvocationTargetException wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    System.out.println(m + " 실패: " + exc);
                } catch (Exception exc) {
                    System.out.println("잘못 사용한 @Test: " + m);
                }
            }
        }
        System.out.printf("성공: %d, 실패: %d%n", passed, tests - passed);
    }
}
```

- 해당 클래스는 명령줄로부터 완전 정규화된 클래스 이름을 받아, 그 클래스에서 @Test 애너테이션이 달린 메서드를 차례로 호출한다.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 코드 39-4 매개변수 하나를 받는 애너테이션 타입 (240-241쪽)
/**
 * 명시한 예외를 던져야만 성공하는 테스트 메서드용 애너테이션
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Throwable> value();
}
```

- 특정 예외를 처리할 수 있도록 하는 애너테이션 타입 정의
- Class<? extends Throwable>에서 와일드카드 타입은 “Throwable을 확장한 클래스의 Class 객체”라는 뜻이며, 따라서 모든 예외(와 오류) 타입을 다 수용한다.
    - 한정적 타입 토큰(아이템 33)의 또 하나의 활용 사례다.

```java
// 코드 39-5 매개변수 하나짜리 애너테이션을 사용한 프로그램 (241쪽)
public class Sample2 {
    @ExceptionTest(ArithmeticException.class)
    public static void m1() {  // 성공해야 한다.
        int i = 0;
        i = i / i;
    }

    @ExceptionTest(ArithmeticException.class)
    public static void m2() {  // 실패해야 한다. (다른 예외 발생)
        int[] a = new int[0];
        int i = a[1];
    }

    @ExceptionTest(ArithmeticException.class)
    public static void m3() {
    }  // 실패해야 한다. (예외가 발생하지 않음)
}
```

- 특정 예외를 처리하는 애너테이션 적용 예시

```java
import item39.markerannotation.Test;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

// 마커 애너테이션과 매개변수 하나짜리 애너태이션을 처리하는 프로그램 (241-242쪽)
public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class<?> testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(Test.class)) {
                tests++;
                try {
                    m.invoke(null);
                    passed++;
                } catch (InvocationTargetException wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    System.out.println(m + " 실패: " + exc);
                } catch (Exception exc) {
                    System.out.println("잘못 사용한 @Test: " + m);
                }
            }

            if (m.isAnnotationPresent(ExceptionTest.class)) {
                tests++;
                try {
                    m.invoke(null);
                    System.out.printf("테스트 %s 실패: 예외를 던지지 않음%n", m);
                } catch (InvocationTargetException wrappedEx) {
                    Throwable exc = wrappedEx.getCause();
                    Class<? extends Throwable> excType =
                            m.getAnnotation(ExceptionTest.class).value();
                    if (excType.isInstance(exc)) {
                        passed++;
                    } else {
                        System.out.printf(
                                "테스트 %s 실패: 기대한 예외 %s, 발생한 예외 %s%n", m, excType.getName(), exc);
                    }
                } catch (Exception exc) {
                    System.out.println("잘못 사용한 @ExceptionTest: " + m);
                }
            }
        }

        System.out.printf("성공: %d, 실패: %d%n", passed, tests - passed);
    }
}
```

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 코드 39-6 배열 매개변수를 받는 애너테이션 타입 (242쪽)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Exception>[] value();
}
```

- 예외를 여러 개 명시하고 그중 하나가 발생하면 성공하도록 배열로 선언

```java
import java.util.ArrayList;
import java.util.List;

// 배열 매개변수를 받는 애너테이션을 사용하는 프로그램 (242-243쪽)
public class Sample3 {

    // 코드 39-7 배열 매개변수를 받는 애너테이션을 사용하는 코드 (242-243쪽)
    @ExceptionTest({IndexOutOfBoundsException.class,
            NullPointerException.class})
    public static void doublyBad() {   // 성공해야 한다.
        List<String> list = new ArrayList<>();

        // 자바 API 명세에 따르면 다음 메서드는 IndexOutOfBoundsException이나
        // NullPointerException을 던질 수 있다.
        list.addAll(5, null);
    }
}
```

```java
// 배열 매개변수를 받는 애너테이션을 처리하는 코드 (243쪽)
if (m.isAnnotationPresent(ExceptionTest.class)) {
    tests++;
    try {
        m.invoke(null);
        System.out.printf("테스트 %s 실패: 예외를 던지지 않음%n", m);
    } catch (Throwable wrappedExc) {
        Throwable exc = wrappedExc.getCause();
        int oldPassed = passed;
        Class<? extends Throwable>[] excTypes =
                m.getAnnotation(ExceptionTest.class).value();
        for (Class<? extends Throwable> excType : excTypes) {
            if (excType.isInstance(exc)) {
                passed++;
                break;
            }
        }
        if (passed == oldPassed)
            System.out.printf("테스트 %s 실패: %s %n", m, exc);
    }
}
```

```java
import java.lang.annotation.*;

// 코드 39-8 반복 가능한 애너테이션 타입 (243-244쪽)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(ExceptionTestContainer.class)
public @interface ExceptionTest {
    Class<? extends Throwable> value();
}
```

- 자바 8에서는 여러 개의 값을 받는 애너테이션을 다른 방식으로도 만들 수 있다.
    - 배열 매개변수를 사용하는 대신 애너테이션에 @Repeatable 매타애너테이션을 다는 방식이다.

```java
// 반복 가능한 애너테이션의 컨테이너 애너테이션 (244쪽)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTestContainer {
    ExceptionTest[] value();
}
```

- 반복 가능 애너테이션을 여러 개 달면 하나만 달았을 때와 구분하기 위해 해당 ‘컨테이너’ 애너테이션 타입이 적용된다.

```java
// 코드 39-10 반복 가능 애너테이션 다루기 (244-245쪽)
if (m.isAnnotationPresent(ExceptionTest.class)
        || m.isAnnotationPresent(ExceptionTestContainer.class)) {
    tests++;
    try {
        m.invoke(null);
        System.out.printf("테스트 %s 실패: 예외를 던지지 않음%n", m);
    } catch (Throwable wrappedExc) {
        Throwable exc = wrappedExc.getCause();
        int oldPassed = passed;
        ExceptionTest[] excTests =
                m.getAnnotationsByType(ExceptionTest.class);
        for (ExceptionTest excTest : excTests) {
            if (excTest.value().isInstance(exc)) {
                passed++;
                break;
            }
        }
        if (passed == oldPassed)
            System.out.printf("테스트 %s 실패: %s %n", m, exc);
    }
}
```

- 반복 가능 애너테이션을 처리하도록 수정한 코드

<aside>
💡 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.

</aside>