# 아이템 33. 타입 안전 이종 컨테이너를 고려하라

## 핵심 정리

### 핵심 정리: 타입 토큰을 사용한 타입 안전 이종 컨테이너

- `타입 안전 이종 컨테이너: 한 타입의 객체만 담을 수 있는 컨테이너가 아니라 여러 다른 타입 (이종)을 담을 수 있는 타입 안전한 컨테이너.`
    - **컨테이너**란 객체를 담을 수 있는 클래스를 의미
    - **이종 컨테이너**란 서로 다른 타입을 넣을 수 있도록하는 것을 의미
- `타입 토큰: String.class 또는 Class<String>`
- `타입 안전 이종 컨테이너 구현 방법: 컨테이너가 아니라 "키"를 매개변수화 하라!`

```java
public class Favorites {
    private Map<Class<?>, Object> map = new HashMap<>();

    public <T> void put(Class<T> clazz, T value) {
        this.map.put(Objects.requireNonNull(clazz), clazz.cast(value));
    }

    public <T> T get(Class<T> clazz) {
        return clazz.cast(this.map.get(clazz));
    }

    public static void main(String[] args) {
        Favorites favorites = new Favorites();
        favorites.put(String.class, "foo");
        favorites.put(Integer.class, 2);

//        favorites.put(List<Integer>.class, List.of(1, 2, 3));
//        favorites.put(List<String>.class, List.of("a", "b", "c"));

//        List list = favorites.get(List.class);
//        list.forEach(System.out::println);
    }
}
```

- Integer.class와 같은 형태를 클래스 리터럴이라고 한다.
- favorites.put((Class) String.class, 1) 와 같이 값을 넣는 경우 타입 안정성을 깨뜨릴 수 있다.
    - 값을 꺼낼때 ClassCastException 발생
    - 값을 넣을때 값과 타입을 한번더 검증하는 로직 추가하는 것으로 방어
        - 컴파일 타임에 잡는 것은 어려움

### 핵심 정리: 한정적 타입 토큰

- `한정적 타입 토큰을 사용한다면, 이종 컨테이너에 사용할 수 있는 타입을 제한할 수 있다.`
    - `AnnotatedElement.<T extends Annotation> T getAnnotation(Class<T> annotationClass);`
- `asSubclass 메서드`
    - `메서드를 호출하는 Class 인스턴스를 인수로 명시한 클래스로 형변환 한다.`

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface FindMe {
}
```

```java
@FindMe
public class MyService {
}
```

```java
// 코드 33-5 asSubclass를 사용해 한정적 타입 토큰을 안전하게 형변환한다. (204쪽)
public class PrintAnnotation {

    static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName) {
        Class<?> annotationType = null; // 비한정적 타입 토큰
        try {
            annotationType = Class.forName(annotationTypeName);
        } catch (Exception ex) {
            throw new IllegalArgumentException(ex);
        }
        return element.getAnnotation(annotationType.asSubclass(Annotation.class));
    }

    // 명시한 클래스의 명시한 애너테이션을 출력하는 테스트 프로그램
    public static void main(String[] args) throws Exception {
        System.out.println(getAnnotation(MyService.class, FindMe.class.getName()));
    }
}
```

- `asSubclass(Annotation.class)`: Annotation.class의 하위 타입으로 변환해준다.

## 완벽 공략

### 완벽 공략 47. 수퍼 타입 토큰

`익명 클래스와 제네릭 클래스 상속을 사용한 타입 토큰`

- `닐 게프터의 슈퍼 타입 토큰`
    - [https://gafter.blogspot.com/2006/12/super-type-tokens.html](https://gafter.blogspot.com/2006/12/super-type-tokens.html)
    - [https://gafter.blogspot.com/2007/05/limitation-of-super-typetokens.html](https://gafter.blogspot.com/2007/05/limitation-of-super-typetokens.html)
- `상속을 사용한 경우 제네릭 타입을 알아낼 수 있다. 이 경우에는 제네릭 타입이 제거되지 않기 때문에…`

```java
public class GenericTypeInfer {

    static class Super<T> {
        T value;
    }

    public static void main(String[] args) throws NoSuchFieldException {
        Super<String> stringSuper = new Super<>();
        System.out.println(stringSuper.getClass().getDeclaredField("value").getType());

        // (new Super<String>(){}): 익명 내부 클래스
        Type type = (new Super<String>(){}).getClass().getGenericSuperclass();
        ParameterizedType pType = (ParameterizedType) type;
        Type actualTypeArgument = pType.getActualTypeArguments()[0];
        System.out.println(actualTypeArgument);
    }
}
```

- 익명 내부 클래스는 클래스 선언임과 동시에 인스턴스까지 생성한 것이다.

**리스트의 상세 타입을 추론하는 방법**

```java
public abstract class TypeRef<T> {
    private final Type type;

    protected TypeRef() {
        ParameterizedType superclass = (ParameterizedType) getClass().getGenericSuperclass();
        type = superclass.getActualTypeArguments()[0];
    }

    @Override
    public boolean equals(Object o) {
        return o instanceof TypeRef && ((TypeRef) o).type.equals(type);
    }

    @Override
    public int hashCode() {
        return type.hashCode();
    }

    public Type getType() {
        return type;
    }
}
```

```java
public class Favorites2 {

    private final Map<TypeRef<?>, Object> favorites = new HashMap<>();

    public <T> void put(TypeRef<T> typeRef, T thing) {
        favorites.put(typeRef, thing);
    }

    @SuppressWarnings("unchecked")
    public <T> T get(TypeRef<T> typeRref) {
        return (T) (favorites.get(typeRref));
    }

    public static void main(String[] args) {
        Favorites2 f = new Favorites2();

        TypeRef<List<String>> stringTypeRef = new TypeRef<>() {
        };
        System.out.println(stringTypeRef.getType());

        TypeRef<List<Integer>> integerTypeRef = new TypeRef<>() {
        };
        System.out.println(integerTypeRef.getType());

        f.put(stringTypeRef, List.of("a", "b", "c"));
        f.put(integerTypeRef, List.of(1, 2, 3));
        f.get(stringTypeRef).forEach(System.out::println);
        f.get(integerTypeRef).forEach(System.out::println);
    }
}
```

**슈퍼타입 토큰의 제약사항 예시**

```java
class Oops {
    static Favorites2 f = new Favorites2();

    static <T> List<T> favoriteList() {
        TypeRef<List<T>> ref = new TypeRef<>() {
        };
        System.out.println(ref.getType());

        List<T> result = f.get(ref);
        if (result == null) {
            result = new ArrayList<T>();
            f.put(ref, result);
        }
        return result;
    }

    public static void main(String[] args) {
        List<String> ls = favoriteList();

        List<Integer> li = favoriteList();
        li.add(1);

        for (String s : ls) System.out.println(s);
    }
}
```

- favoriteList() 정의된 코드 중 `TypeRef<List<T>> ref = new TypeRef<>(){}` 의 타입을 확인해보면 List<T> 이다.
    - 처음 가져온 ls의 hashcode 값과 li가 동일하다.
    - 따라서 li에는 List<String>인 ls의 인스턴스가 담기게 되고 결국 ls에 Integer 1이라는 값을 넣어지게 되는것이다.
        - 값을 꺼낼때 ClassCastException이 발생
- 결론은 위 코드와 같이 수퍼 타입 토큰 방식에 구멍이 있다는 사실이다.

# References

- 수퍼 타입 토큰: [https://gafter.blogspot.com/search?q=super+type+token](https://gafter.blogspot.com/search?q=super+type+token)