# 아이템 11. equals를 재정의 하려거든 hashCode도 재정의하라

## 핵심 정리

- `hashCode 규약`
    - `equals 비교에 사용하는 정보가 변경되지 않았다면 hashCode는 매번 같은 값을 리턴해야 한다. (변경되거나, 애플리케이션을 다시 실행했다면 달라질 수 있다.)`
    - `**두 객체에 대한 equals가 같다면, hashCode의 값도 같아야 한다.**`
    - `두 객체에 대한 equals가 다르더라도, hashCode의 값은 같을 수 있지만 **해시 테이블 성능을 고려해 다른 값을 리턴하는 것이 좋다.**`

```java
public class HashMapTest {

    public static void main(String[] args) {
        Map<PhoneNumber, String> map = new HashMap<>();

        PhoneNumber number1 = new PhoneNumber(123, 456, 7890);
        PhoneNumber number2 = new PhoneNumber(456, 789, 1111);

        // 같은 인스턴스인데 다른 hashCode
				//  hashMap에 값을 저장할 때 저장할 객체의 hashCode를 기반으로 어느 해쉬 버킷에 저장할지 결정하게 된다.
        //  같은 인스턴스지만 서로 다른 hashcode를 반환한다면 각기 다른 버킷에 들어가게 된다.
        // 다른 인스턴스인데 같은 hashCode를 쓴다면?
        //  해당 경우가 해시 충돌에 해당하는데
        //  값을 저장하는 경우 동일한 해쉬 버킷에 링크드 리스트 형태로 인스턴스들이 들어가게 된다.
        //  때문에 해당 값을 맵에서 가져오는 경우 링크드 리스트의 크기인 O(n)만큼 소요되게 된다.
        System.out.println(number1.equals(number2));
        System.out.println(number1.hashCode());
        System.out.println(number2.hashCode());

        map.put(number1, "hello");
        map.put(number2, "world");

        String s = map.get(number2);
        System.out.println(s);
    }
}
```

**HashMap에 값을 넣는 과정**: 넣고자 하는 값의 해쉬 코드를 가져와 어느 해쉬 버킷에 넣을지 결정을 하게 된다.

**동일 인스턴스인데 다른 hashCode를 반환하는 경우**

```java
PhoneNumber number1 = new PhoneNumber(123, 456, 7890);
PhoneNumber number2 = new PhoneNumber(123, 456, 7890);

System.out.println(number1.equals(number2)); // true
System.out.println(number1.hashCode()); // 446
System.out.println(number2.hashCode()); // 123

map.put(number1, "hello");
map.put(number2, "world");

map.get(number1); // hello
map.get(number2); // world
map.get(new PhoneNumber(123, 456, 7890)); // null
```

- 동일한 인스턴스지만 서로 다른 hashCode를 반환하는 경우 값을 꺼낸 결과를 보면 알 수 있듯이 각자 다른 값을 저장하고 있음을 확인 할 수 있다.
    - hashMap에 값을 저장할 때 저장할 객체의 hashCode를 기반으로 어느 해쉬 버킷에 저장할지 결정하게 된다. 같은 인스턴스지만 서로 다른 hashcode를 반환한다면 각기 다른 버킷에 들어가게 된다
    - 그렇기 때문에 equals 재정의 시 사용된 필드와 동일하게 hashCode도 재정의가 필요한 이유이다.

**서로 다른 인스턴스지만 같은 hashCode를 반환하는 경우**

```java
PhoneNumber number1 = new PhoneNumber(123, 456, 7890);
PhoneNumber number2 = new PhoneNumber(456, 789, 0123);

System.out.println(number1.equals(number2)); // false
System.out.println(number1.hashCode()); // 42
System.out.println(number2.hashCode()); // 42

map.put(number1, "hello");
map.put(number2, "world");

map.get(number1); // hello
map.get(number2); // world
map.get(new PhoneNumber(123, 456, 7890)); // hello
```

- 해당 경우가 해시 충돌에 해당하는데, 값을 저장하는 경우 동일한 해쉬 버킷에 링크드 리스트 형태로 인스턴스들이 들어가게 된다. 때문에 해당 값을 맵에서 가져오는 경우 링크드 리스트의 크기인 O(n)만큼 소요되게 된다.
    - hashMap을 사용하는 장점이 없다. 링크드 리스트를 사용하는 것과 동일한 경우
- `hashCode 구현 방법`
    - `핵심 필드 하나의 값의 해쉬값을 계산해서 result 값을 초기화 한다.`
    - `해쉬 값 계산하기`
        - `기본 타입은 Type.hashCode`
        - `참조타입은 해당 필드의 hashCode`
        - `배열은 모든 원소를 재귀적으로 위의 로직을 적용하거나, Arrays.hashCode`
        - `result = 31 * result + 해당 필드의 hashCode 계산 값`
    - `result를 리턴한다.`

```java
// 코드 11-2 전형적인 hashCode 메서드 (70쪽)
@Override 
public int hashCode() {
    int result = Short.hashCode(areaCode); // 1
    result = 31 * result + Short.hashCode(prefix); // 2
    result = 31 * result + Short.hashCode(lineNum); // 3
    return result;
}
```

- 왜 31인가?
    - 홀수를 사용
        - 짝수로 연산하면 0이 채워지면서 값이 이상해질 수 있다.
    - 해싱을 할 때, 31이 충돌이 가장 적었다는…
- `hashCode 구현 대안`
    - `hashCode 구현 방법 중에 google guava라는 것이 있다.`
        - `com.google.common.hash.Hashing`
    - `Objects 클래스의 hash 메서드`
    - `캐싱을 사용해 불변 클래스의 해시 코드 계산 비용을 줄일 수 있다.`

```java
// equals를 재정의하면 hashCode로 재정의해야 함을 보여준다. (70-71쪽)
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
		...

		// 해시코드를 지연 초기화하는 hashCode 메서드 - 스레드 안정성까지 고려해야 한다. (71쪽)
    private int hashCode; // 자동으로 0으로 초기화된다.

    @Override 
		public int hashCode() {
        int result = hashCode;
        if (result == 0) {
            result = Short.hashCode(areaCode);
            result = 31 * result + Short.hashCode(prefix);
            result = 31 * result + Short.hashCode(lineNum);
            this.hashCode = result;
        }
        return result;
    }
}
```

- 해싱 계산 비용이 많이 들고 해당 객체가 불변이라면 위와 같이 해시 값을 캐싱하는 방법도 고려할 수 있다.
- 생성자가 호출되는 시점이 아닌 hashCode()가 호출되는 시점에 계산한다.(지연 초기화)
- `주의 할 것`
    - **`지연 초기화 기법을 사용하는 경우, 멀티 스레드 환경을 고려해야한다.(아이템 83)`**
        - hashCode()를 여러 스레드가 동시에 호출할 수 있다.
    - `성능 때문에 핵심 필드를 해시코드 계산할 때 빼면 안 된다.`
        - equals()에서 사용되는 필드는 hashCode()에 동일하게 사용해야한다.
    - `해시코드 계산 규칙을 API에 노출하지 않는 것이 좋다.`
        - hashCode() 내부 구현에 따라 로직이 달라지는 코드를 작성하면 안된다.

## 완벽 공략

### 완벽 공략 27. 해시맵 내부의 연결 리스트

- `p68, 연결 리스트`

`내부 구현은 언제든지 바뀔 수도 있다.`

- `자바 8에서 해시 충돌시 성능 개선을 위해 내부적으로 동일한 버켓에 일정 개수 이상의 엔트리가 추가되면, 연결 리스트 대신 이진 트리를 사용하도록 바뀌었다.`
    - [`https://dzone.com/articles/hashmap-performance`](https://dzone.com/articles/hashmap-performance)
- `연결 리스트에서 어떤 값을 찾는데 걸리는 시간은?`
    - O(n)
- `이진 트리에서 어떤 값을 찾는데 걸리는 시간은?`
    - O(logN)
- 왜 ArrayList가 아니라 LinkedList일까?
    - 시간 복잡도는 O(n)으로 동일하기 때문에 공간의 활용성을 고려하지 않았을까

### 완벽 공략 28. 스레드 안전

- `p70, 해시 충돌이 더욱 적은 방법을 꼭 써야 한다면…`
- `p71, 클래스를 스레드 안전하게 만들도록 신경 써야 한다.`

`멀티 스레드 환경에서 안전한 코드, Thread-safety`

- `가장 안전한 방법은 여러 스레드 간에 공유하는 데이터가 없는 것!`
- `공유하는 데이터가 있다면` 다음 방법을 사용하면 스레드 안전하다.
    - `Synchronization`
    - `ThreadLocal`
    - `불변 객체 사용`
    - `Synchronized 데이터 사용`
    - `Concurrent 데이터 사용`

```java
// equals를 재정의하면 hashCode로 재정의해야 함을 보여준다. (70-71쪽)
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
		...

		// 해시코드를 지연 초기화하는 hashCode 메서드 - 스레드 안정성까지 고려해야 한다. (71쪽)
    private volatile int hashCode; // 자동으로 0으로 초기화된다.

    @Override 
		public int hashCode() {
        if (this.hashCode != 0) {
            return hashCode;
        }

        synchronized (this) {
            int result = hashCode;
            if (result == 0) {
                result = Short.hashCode(areaCode);
                result = 31 * result + Short.hashCode(prefix);
                result = 31 * result + Short.hashCode(lineNum);
                this.hashCode = result;
            }
            return result;
        }
    }
}
```

- `volatile` 키워드를 사용하면 메인 메모리에 저장된다.