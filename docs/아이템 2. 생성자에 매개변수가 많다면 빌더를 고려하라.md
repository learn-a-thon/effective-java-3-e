# 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

## 핵심정리

- `정적 팩터리와 생성자에 선택적 매개변수가 많을 때 고려할 수 있는 방안`
- **`대안1**: 점층적 생성자 패턴 또는 생성자 체이닝`
    - `매개변수가 늘어나면 클라이언트 코드를 작성하거나 읽기 어렵다.`

```java
public class Foo {
    private Long id;
    private String name;
    private int age;
    private int weight;
    private int height;

		// 부생성자
    public Foo(Long id, String name, int age) {
        this(id, name, age, 0, 0);
    }

		// 부생성자
    public Foo(Long id, String name, int age, int weight) {
        this(id, name, age, weight, 0);
    }

		// 주생성자
    public Foo(Long id, String name, int age, int weight, int height) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.weight = weight;
        this.height = height;
    }
}
```

- **`대안2**: 자바빈즈 패턴`
    - `완전한 객체를 만들려면 메서드를 여러번 호출해야 한다. (일관성이 무너진 상
    태가 될 수도 있다.)`
    - `클래스를 불변으로 만들 수 없다.`

자바빈즈 패턴은 자바 표준 스펙으로 클래스에 있는 필드에 대한 getter, setter를 정의하는 것을 말한다.

```java
public class Foo {
    private Long id;
    private String name;
    private int age;
    private int weight;
    private int height;

		...

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    ...
}
```

```java
public static void main(String[] args) {
    Foo foo = new Foo();
    foo.setId(1L);
}
```

자바 빈즈 패턴의 경우 위와 같이 기본 생성자를 통해 인스턴스를 생성하고 setter를 통해 초기값을 설정할 수 있다. 다만 다음과 같은 특징이 있다.

- 초기값이 설정되지 않은 상태에서 객체가 사용될 위험성이 높다.
- 만약 사용해야한다면 파라미터가 존재하는 생성자와 자바 빈즈 패턴 방식을 혼용해서 사용하는 것이 좋다.
- setter가 열려있게 된다면 immutable한 객체를 만들 수 없다.
    - immutable하기 때문에 프리징이라는 기술을 대안으로 사용할 수 있다고 한다.
        - 현업에서 잘사용되지 않는다.
    - 프리징은 js에 있는 함수라고 한다.
- setter를 사용하면 어느 것까지 값을 설정해야 객체가 완전해지는지 알 수 없다.
- `권장하는 방법: 빌더 패턴`
    - `플루언트 API 또는 메서드 체이닝을 한다.`
        
        ```java
        public class Foo {
            private Long id;
            private String name;
            private int age;
            private int weight;
            private int height;
        
            public Foo(Long id, String name, int age, int weight, int height) {
                this.id = id;
                this.name = name;
                this.age = age;
                this.weight = weight;
                this.height = height;
            }
        
            public static FooBuilder builder(Long id, String name) {
                return new FooBuilder(id, name);
            }
            
            public static class FooBuilder {
                private Long id;
                private String name;
                private int age;
                private int weight;
                private int height;
        
                public FooBuilder(Long id, String name) {
                    this.id = id;
                    this.name = name;
                }
                
                public FooBuilder age(int age) {
                    this.age = age;
                    return this;
                }
                public FooBuilder weight(int weight) {
                    this.weight = weight;
                    return this;
                }
                public FooBuilder height(int height) {
                    this.height = height;
                    return this;
                }
        
                public Foo build() {
                    return new Foo(id, name, age, weight, height);
                }
            }
        }
        ```
        
        ```java
        public static void main(String[] args) {
            Foo foo = Foo.builder(1L, "홍길동")
                    .age(20)
                    .height(200)
                    .weight(1000)
                    .build();
        }
        ```
        
        - 필수적인 필드는 강제할 수 있고 부가적인 정보는 선택적으로 설정할 수 있게 할 수 있다.
        - 빌더는 코드를 어렵게 만든다.(코드 중복)
        - immutable 하게 만들 수 있다.
        - lombok의 @Builder 를 사용하면 간편하게 사용할 수 있다.
            - 단점
                - annotation processor 참고
                - @Builder를 사용하면 모든 파라미터를 받는 생성자가 생긴다.
                    - @AllArgsConstructor(access = AccessLevel.PRIVATE)로 제한할 수 있다.
                - Lombok을 사용하는 경우 필수값을 지정할 수 없다.
    - `계층적으로 설계된 클래스와 함께 사용하기 좋다.`
    - `점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈
    보다 훨씬 안전하다.`

```java
public abstract class Pizza {

    final Set<Topping> toppings;

    Pizza(Builder<?> builder) {
        toppings = builder.toppings.clone();
    }

    public enum Topping {
        HAM, MUSHROOM, ONION, PEPPER, SAUSAGE
    }

    abstract static class Builder<T extends Builder<T>> {
        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }

        abstract Pizza build();

        // 하위 클래스는 이 메서드를 재정의(overriding) 하여
        // "this"를 반환하도록 해야 한다.
        protected abstract T self();
    }
}

// 하위 클래스
public class NyPizza extends Pizza {

    private final Size size;

    NyPizza(Builder builder) {
        super(builder);
        this.size = builder.size;
    }

    @Override
    public String toString() {
        return toppings + "로 토핑한 " + size + "크기의 뉴욕 피자";
    }

    public enum Size {
        SMALL, MEDIUM, BIG
    }

    public static class Builder extends Pizza.Builder<NyPizza.Builder> {
        private final Size size;

        public Builder(Size size) {
            this.size = Objects.requireNonNull(size);
        }

        @Override
        Pizza build() {
            return new NyPizza(this);

        }

        @Override
        protected Builder self() {
            return this;
        }
    }
}

// 하위 클래스
public class Calzone extends Pizza {
    private final boolean sauceInside;

    Calzone(Builder builder) {
        super(builder);
        this.sauceInside = builder.sauceInside;
    }

    @Override
    public String toString() {
        return toppings + "로 토핑한 소스 포함이 " + sauceInside + " 인 Calzone 피자";
    }

    public static class Builder extends Pizza.Builder<Calzone.Builder> {
        private boolean sauceInside = false;

        public Builder sauceInside() {
            this.sauceInside = true;
            return this;
        }

        @Override
        Pizza build() {
            return new Calzone(this);

        }

        @Override
        protected Builder self() {
            return this;
        }
    }
}
```

```java
public class PizzaTest {

    public static void main(String[] args) {
        Pizza nyPizza = new NyPizza.Builder(NyPizza.Size.MEDIUM)
                .addTopping(Pizza.Topping.MUSHROOM)
                .addTopping(Pizza.Topping.ONION)
                .build();

        Pizza calzone = new Calzone.Builder()
                .sauceInside()
                .addTopping(Pizza.Topping.SAUSAGE)
                .build();

        System.out.println("nyPizza = " + nyPizza);
        System.out.println("calzone = " + calzone);
    }
}
```

```java
// Pizza.Builder
abstract static class Builder<T extends Builder<T>> {
    EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

    public T addTopping(Topping topping) {
        toppings.add(Objects.requireNonNull(topping));
        return self();
    }

    abstract Pizza build();

    // 하위 클래스는 이 메서드를 재정의(overriding) 하여
    // "this"를 반환하도록 해야 한다.
    protected abstract T self();
}
```

addTopping() 메소드에서 반환 타입을 살펴 보면 제네릭으로 정의돼있고 self() 메소드를 하위 클래스에서 재정의하여 반환하도록 돼있다. 만약 제네릭이 아닌 다음과 같이 사용한 경우 클라이언트 쪽에서 Builder 클래스 사용시 타입 케스팅해야하는 불편함이 있다.

```java
public Builder<T> addTopping(Topping topping) {
		...
		return this;
}

// 클라이언트
public class PizzaTest {

    public static void main(String[] args) {
        Pizza nyPizza = (NyPizza) new NyPizza.Builder(NyPizza.Size.MEDIUM)
                .addTopping(Pizza.Topping.MUSHROOM)
                .addTopping(Pizza.Topping.ONION)
                .build();
		}
}
```

또한 위와 같이 처리하는 경우 하위 클래스의 Builder에 정의된 기능을 사용할 수 없게 된다.

따라서 하위 클래스에서 self()를 재정의 함으로써 빌더 팩토리 계층 구조를 재활용 할 수 있는 것이다.

## 완벽 공략

### 완벽 공략 6. 자바빈(JavaBean)이란?

- `p15, 자바빈즈, 게터, 세터`
- (주로 GUI에서) 재사용 가능한 소프트웨어 컴포넌트
    - 참고: [https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/)
- java.beans 패키지 안에 있는 모든 것
    - 그 중에서도 자바빈이 지켜야 할 규약
        - 아규먼트 없는 기본 생성자
            - 이것이 필요한 이유? 객체를 만들기 편하기 때문
        - getter와 setter 메소드 이름 규약
        - Serializable 인터페이스 구현
    - 하지만 실제로 오늘날 자바빈 스팩 중에서도 getter와 setter가 주로 쓰는 이유는?
        - JPA나 스프링과 같은 여러 프레임워크에서 리플렉션을 통해 특정 객체의 값을 조회하거나 설정하기 때문입니다.

<aside>
💡 GUI 툴용으로 만드는 것이 아니라면 자바빈 규약을 반드시 지켜야하는 것은 아니다.

</aside>

- 참고(java 17 record(getter, setter)):
    - [https://scshim.tistory.com/372](https://scshim.tistory.com/372)
    - [https://coding-start.tistory.com/355](https://coding-start.tistory.com/355)

### 완벽 공략 7. 객체 얼리기(freezing)

- `p17, 객체 얼리기 (freezing)`

임의의 객체를 불변 객체로 만들어주는 기능

```jsx
'use strict' // 'use strict'에서만 Object.freeze 사용가능

const data = {
		'name': 'hello',
	  'age': 10
}

Object.freeze(data);
```

- Object.freeze()에 전달한 객체는 그뒤로 변경될 수 없다.
    - 새 프로퍼티를 추가하지 못함
    - 기존 프로퍼티를 제거하지 못함
    - 기존 프로퍼티 값을 변경하지 못함
    - 프로토타입을 변경하지 못함
- strict 모드에서만 동작함
- 비슷한 류의 펑션으로 Object.seal()과 Object.preverntExtensions()가 있다.

거의 사용하지 않을듯..

### 완벽 공략 8. 빌더 패턴

- `p17, 빌더 패턴`

동일한 프로세스를 거쳐 다양한 구성의 인스턴스를 만드는 방법

- 복잡한 객체를 만드는 프로세스를 독립적으로 분리할 수 있다.

### 완벽 공략 9. IllegalArgumentException

- `p19, IllegalArgumentException`

잘못된 인자를 넘겨 받았을 때 사용할 수 있는 기본 런타임 예외

IllegalArgumentException은 unchecked exception

- **질문1) checked exception과 unchecked exception의 차이?**

checked exception은 try-catch 구문으로 예외에 대한 처리해야하는 exception이고 unchecked exception은 try-catch 구문으로 처리하지 않아도 되는 exception이다.

- **질문2) 간혹 메소드 선언부에 unchecked exception을 선언하는 이유는?**

```jsx
public void updateName(String name) throws IllegalArgumentException {}
```

클라이언트에게 명시적으로 알려주고 싶은 경우 선언한다.

- **질문3) checked exception은 왜 사용할까?**

클라이언트가 예외에 대한 후속 작업을 강제가 필요한 경우 사용한다.

- **과제1) 자바의 모든 RuntimeException 클래스 이름 한번씩 읽어보기.**

[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/RuntimeException.html](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/RuntimeException.html)

- **과제2) 이 링크에 있는 글을 꼭 읽으세요.**

[https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html)

### 완벽 공략 10. 가변인수

- `p21, 가변인수 (varargs) 매개변수를 여러 개 사용할 수 있다.`

여러 인자를 받을 수 있는 가변적인 argument(Var+args)

- 가변인수는 메소드에 오직 하나만 선언할 수 있다.
- 가변인수는 메소드의 가장 마지막 매개변수가 되어야 한다.

```jsx
public class VarargsSample {

    public void printNumber(int... numbers) {
        System.out.println(numbers.getClass().getCanonicalName());
        System.out.println(numbers.getClass().getComponentType());
        System.out.println(Arrays.toString(numbers));
    }

    // Heap Pollution 참고
    public static void main(String[] args) {
        VarargsSample varargsSample = new VarargsSample();
        varargsSample.printNumber(2, 3, 4, 5);
    }
}
```
