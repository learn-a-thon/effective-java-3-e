# 아이템 28. 배열보다는 리스트를 사용하라

## 핵심 정리

`배열과 제네릭은 잘 어울리지 않는다.`

- `배열은 공변 (covariant), 제네릭은 불공변`
    - 공변: 같이 변한다
        - 상속관계에 따라 같이 변한다.
    - 불공변: 같이 변하지 않는다.

```java
public class IntegerToString {
    public static void main(String[] args) {
        // 공변 -> 타입이 String에서 Object 타입으로 변한다.(상속구조라서)
        Object[] anything = new String[10];
        anything[0] = 1;

        // 불공변
        List<String> names = new ArrayList<>();
//        List<Object> objects = names;

//        // 제네릭과 배열을 같이 사용할 수 있다면...
//        List<String>[] stringLists = new ArrayList<String>[1];
//        List<Integer> intList = List.of(42);
//        Object[] objects = stringLists;
//        objects[0] = intList;
//        String s = stringLists[0].get(0);
//        System.out.println(s);
    }
}
```

- 위 코드에서 anything의 실체는 String 배열인데 정수를 넣고 있다.(컴파일러는 이것을 잡지 못한다.)
- `배열은 실체화(reify) 되지만, 제네릭은 실체화 되지 않는다.(소거)`
    - 실체화란 런타임에도 타입을 보존한다는 의미
    - 실체화되지 않는다는 것은 컴파일할 때 제네릭의 타입이 사라진다는 의미

```java
public class MyGeneric {

    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("foo");
        String name = names.get(0);
        System.out.println(name);
    }
}
```

- `new Generic<타입>[배열] 은 컴파일 할 수 없다.`
- `제네릭 소거: 원소의 타입을 컴파일 타임에만 검사하며 런타임에는 알 수 없다.`

```java
// 코드 28-6 배열 기반 Chooser
public class Chooser_Array {
    private final Object[] choiceList;

    public Chooser_Array(Collection choices) {
        choiceList = choices.toArray();
    }

    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList[rnd.nextInt(choiceList.length)];
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3, 4, 5, 6);

        Chooser_Array chooser = new Chooser_Array(intList);

        for (int i = 0; i < 10; i++) {
            Number choice = (Number) chooser.choose();
            System.out.println(choice);
        }
    }
}

// 코드 28-6 리스트 기반 Chooser - 타입 안전성 확보! (168쪽)
public class Chooser<T> {
    private final List<T> choiceList;

    public Chooser(Collection<T> choices) {
        choiceList = new ArrayList<>(choices); // 방어적 복사
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3, 4, 5, 6);

        Chooser<Integer> chooser = new Chooser<>(intList);

        for (int i = 0; i < 10; i++) {
            Number choice = chooser.choose();
            System.out.println(choice);
        }
    }
}
```

## 완벽 공략

### 완벽 공략 42. @SafeVarags

`생성자와 메서드의 제네릭 가변인자에 사용할 수 있는 애노테이션`

- `제네릭 가변인자는 근본적으로 타입 안전하지 않다. (가변인자가 배열이니까, 제네릭 배열과 같은 문제)`
- `가변 인자 (배열)의 내부 데이터가 오염될 가능성이 있다.`
    - 제네릭 타입의 배열을 사용해서…
- `@SafeVarargs를 사용하면 가변 인자에 대한 해당 오염에 대한 경고를 숨길 수 있다.`
- `아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라.`

```java
public class SafeVaragsExample {

//    @SafeVarargs // Not actually safe!
    static void notSafe(List<String>... stringLists) {
        Object[] array = stringLists; // List<String>... => List[], 그리고 배열은 공변이니까.
        List<Integer> tmpList = List.of(42);
        array[0] = tmpList; // Semantically invalid, but compiles without warnings
        String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!
    }

    @SafeVarargs
    static <T> void safe(T... values) {
        for (T value: values) {
            System.out.println(value);
        }
    }

    public static void main(String[] args) {
        SafeVaragsExample.safe("a", "b", "c");
        SafeVaragsExample.notSafe(List.of("a", "b", "c"));
    }
}
```

- 제네릭 배열 코드에서 데이터를 꺼낼때 문제가 발생한다.