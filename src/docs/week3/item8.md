# item8. finalizer와 cleaner 사용을 피하라.

### 객체 소멸자 Finalizer, Cleaner
- 얘는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 
- 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다. 
- 나름의 쓰임새가 있긴 하지만, 기본적으로 쓰지 말아야 한다.
- 그래서 자바 9에서는 Finalizer를 사용 자제 API로 지정하고 Cleaner를 그 대안으로 소개했다. 
- 하지만 얘도 덜 위험하지만, 여전히 예측할 수 없고 느리고 입란적으로 불필요하다.

### 즉시 실행 불가 
- 얘네는 즉시 수행된다는 보장이 없다, 즉 즉시 실행되어야 하는 작업은 절대 할 수 없다.
- 얘네가 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 가비지 컬렉터 구현마다 천차만별이다.

### 수행 여부 보장 불가 
- 접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다.
- 따라서 상태를 영구적으로 수정하는 작업에서는 절대 FINALIZER나 CLeaner에 의존해서는 안된다.
    - Ex) 데이터베이스 같은 공유 자원의 영구 락 해제
- System.gc()나 System.runFinalization 메서드에 현혹되지 말자, 실행될 가능성은 높여줄 수는 있으나 보장해주진 않는다. 
- System.runFinalizerOnExit, Runtime.runFinalizerOnExit도 마찬가지다.

### finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.
- 잡지 못한 예외 때문에, 해당 객체는 마무리가 덜 된 상태로 남을 수 있다.
- 그리고 다른 스레드가 이처럼 훼손된 객체를 사용하려 한다면 어떻게 동작할지 예측할 수 없다.
- 보통은 잡지 못한 예외가 스레드를 중단시키고 스택 추적 내역을 출력하겠지만, 같은 일이 finalizer에서 일어난다면 경고조차 출력하지 않는다.

### finalizer와 cleaner는 심각한 성능 문제도 동반한다.
- finalizer는 가비지 컬렉터의 효율을 떨어트린다.

### finalizer를 사용한 클래스는 FInalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. 
- 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.
- 이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있다. 
- 이렇게 일그러진 객체가 만들어지고 나면, 이 객체의 메서드를 호출해 애초에는 허용되지 않았을 작업을 수행하는 건 일도 아니다. 

### AutoCloseable을 구현해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하도록 하자.
- finalizer, cleaner는 자원의 소유자가 close 메서드를 호출하지 않는 것에  대비한 안전망 역할이다.
- 네이티브 피어와 연결된 객체에서 적절히 활용할 수 있다. 

